<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>这是一篇新文章</title>
    <url>/2023/09/09/test/</url>
    <content><![CDATA[<p>新文章测试。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>数据结构</tag>
        <tag>英格培训</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/08/28/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2023/09/12/%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li><strong>数据对象</strong>是具有相同<u>性质</u>的数据元素的集合，是数据的一个子集。</li>
<li><strong>数据结构</strong>是相互之间存在一种或多种特定<u>关系</u>的数据元素的集合。</li>
<li>同样的数据元素可组成不同的数据结构，不同的数据元素可组成相同的数据结构。</li>
</ul>
<h2 id="数据结构的三要素"><a href="#数据结构的三要素" class="headerlink" title="数据结构的三要素"></a>数据结构的三要素</h2><ul>
<li><p><strong>逻辑结构</strong>：</p>
<p>集合结构：（各个元素同属一个集合，别无其它关系。）</p>
<p>线性结构：一对一（除了第一个元素，所有元素都有唯一前驱；除了最后一个元素，所有元素都有唯一后继。）</p>
<p>树形结构：一对多</p>
<p>图状结构：多对多</p>
</li>
<li><p><strong>数据的运算</strong>：针对于某种逻辑结构，结合实际需求，定义基本运算。</p>
</li>
<li><p><strong>物理结构（存储结构）</strong>： </p>
<p>顺序存储（逻辑上相邻的元素存储在物理位置上也相邻的存储单元中。）</p>
<p>链式存储（逻辑上相邻的元素在物理位置上可以不相邻。）</p>
<p>索引存储（在存储元素信息的同时，还建立附加的<u>索引表</u>。索引表中的每项称为索引项，索引项的一般形 式是（关键字，地址）。）</p>
<p>散列存储（根据元素的关键字直接计算出该元素的存储地址，又称<u>哈希存储</u>。）</p>
<p>注：除了顺序存储其他的都是非顺序存储（离散存储）。</p>
<p>​		数据的存储结构会影响存储空间分配的方便程度。</p>
<p>​		数据的存储结构会影响对数据运算的速度。</p>
<p>​		运算的定义是针对逻辑结构的，运算的实现是针对存储结构的。</p>
</li>
</ul>
<h2 id="数据类型、抽象数据类型"><a href="#数据类型、抽象数据类型" class="headerlink" title="数据类型、抽象数据类型"></a>数据类型、抽象数据类型</h2><ul>
<li><p><strong>数据类型</strong>是一个值的集合和定义在此集合上的一组操作的总称。</p>
<p>原子类型：其值不可再分的数据类型。</p>
<p>结构类型：其值可以再分解为若干成分的数据类型。</p>
</li>
<li><p><strong>抽象数据类型（ADT）</strong>是抽象数据组织及与之相关的操作。</p>
</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul>
<li><p><strong>算法</strong>是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。</p>
</li>
<li><p><strong>算法的五个特性</strong></p>
<p>有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。（注：算法必须是有穷的，而程序可以是无穷的。）</p>
<p>确定性：算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。</p>
<p>可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。</p>
<p>输入：一个算法有零个或多个输入。</p>
<p>输出：一个算法有一个或多个输出。</p>
</li>
<li><p><strong>“好”算法</strong>的特性：正确性、可读性、健壮性、高效率与低存储量需求。</p>
</li>
<li><p><strong>时间复杂度</strong>:衡量时间开销与问题规模n之间的关系。（以最深层的for循环为主）</p>
<p><strong>O(1)&lt;O(㏒₂n)&lt;O(n)&lt;O(n㏒₂n)&lt;O(n²)&lt;O(n³)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)</strong></p>
<p>加法规则：T(n)&#x3D;O(f(n))+O(g(n))&#x3D;O(max(f(n),g(n)))</p>
<p>乘法规则：T(n)&#x3D;O(f(n))×O(g(n))&#x3D;O(f(n)×g(n))</p>
</li>
<li><p><strong>空间复杂度</strong>：空间开销（内存开销）与问题规模n之间的关系。（以最高维的数组为主或者等于递归调用的深度）</p>
<p>算法<strong>原地工作</strong>——算法所需内存空间为常量</p>
<p>（用法同上。）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2023/09/15/%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul>
<li><p><strong>栈</strong>是只允许在一端进行插入或者删除操作的<strong>线性表</strong>。</p>
</li>
<li><p><strong>栈顶</strong>：允许插入和删除的一端。</p>
<p><strong>栈底</strong>：不允许插入和删除的一端。</p>
<p><strong>空栈</strong>：空表。</p>
</li>
<li><p>特点：<strong>先进后出</strong>（LIFO）</p>
</li>
<li><p>基本操作：</p>
<p>InitStack(&amp;S):初始化栈。构造一个空栈S，分配内存空间。</p>
<p>DestroyStack(&amp;L):销毁栈。销毁并释放栈S所占用的内存空间。</p>
<p>Push(&amp;S,x):进栈。若栈S未满，则将x加入使之成为新栈顶。</p>
<p>Pop(&amp;S,&amp;x):出栈。若栈S非空，则弹出栈顶元素，并用x返回。</p>
<p>其他常用操作：</p>
<p>StackEmpty(S):判断一个栈S是否为空。若S为空，则返回true，否则返回false。</p>
</li>
<li><p>n个不同的元素进栈，出栈元素不同排列的个数为(1&#x2F;(n+1))C(2n下标，n上标)。（卡特兰数）</p>
</li>
<li><p><strong>顺序栈</strong>：用顺序存储方式实现的栈。</p>
<p>定义操作：静态数组存放栈中的元素；栈顶指针。</p>
<p>（顺序存储：给各个数据元素分配连续的存储空间，大小为MaxSize * sizeof(ElemType)。）</p>
<p>进栈操作：<code>S.data[++S.top]=x</code>。</p>
<p>出栈操作：<code>x=S.data[S.top--]</code>。</p>
<p>读栈操作：<code>x=S.data[S.top-1]</code>。</p>
<p>栈满的条件：<code>top==MaxSize</code>。</p>
<p>顺序栈的缺点：栈的大小不可变。</p>
</li>
<li><p><strong>共享栈</strong>：两个栈共享同一片空间。</p>
<p>需要两个栈顶指针，分别从内存两端向内填数据。（<code>S.top0=-1；S.top1=MaxSize</code>）</p>
<p>栈满条件：<code>top0 + 1 == top1</code>。</p>
</li>
<li><p><strong>链栈</strong>：用链式存储方式实现的栈。</p>
<p>用法跟链表基本一致，只是进栈&#x2F;出栈都只能在栈顶一端进行（链头作为栈顶）。</p>
</li>
</ul>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ul>
<li><p><strong>队列</strong>是只允许在一端进行插入，在另一端删除的<strong>线性表</strong>。</p>
</li>
<li><p><strong>队头</strong>：运行删除的一端。</p>
<p><strong>队尾</strong>：允许插入的一端。</p>
<p><strong>空队列</strong>：空表。</p>
</li>
<li><p>特点：<strong>先进先出</strong>（FIFO）</p>
</li>
<li><p>基本操作：</p>
<p>InitQueue(&amp;Q):初始化队列。构造一个空队列Q，分配内存空间。</p>
<p>DestroyQueue(&amp;Q):销毁队列。销毁并释放队列Q所占用的内存空间。</p>
<p>EnQueue(&amp;Q,x):入队。若队列Q未满，则将x加入使之成为新队尾。</p>
<p>DeQueue(&amp;Q,&amp;x):出队。若队列Q非空，删除队头元素，并用x返回。</p>
<p>GetHead(Q,&amp;x):读队头元素，若队列Q非空，则将队头元素赋值给x。</p>
<p>其他常用操作：</p>
<p>QueueEmpty(Q):判断一个队列Q是否为空。若Q为空，则返回true，否则返回false。</p>
</li>
<li><p><strong>队列的顺序实现</strong>：</p>
<p>定义操作：用静态数组存放队列元素，还应有队头指针（front）和队尾指针（rear）（指向队尾元素的后一个位置）。</p>
<p>判空操作：<code>Q.rear==Q.front</code>。</p>
<p>入队操作：<code>Q.rear=(Q.rear+1)%MaxSize</code> 可以将存储空间在逻辑上变成了“环状”。（<strong>循环队列</strong>）</p>
<p>​					队列已满的条件：队尾指针的再下一个位置是队头，即(Q.rear+1)%MaxSize&#x3D;&#x3D;Q.front。（代价：牺牲一个存储单元。）</p>
<p>出队操作：<code>Q.front=(Q.front+1)%MaxSize</code>  队头指针后移。</p>
<p>查找操作：<code>x=Q.data[Q.front]</code>。</p>
<p><strong>队列元素个数</strong>：(rear+MaxSize-front)%MaxSize。</p>
<p>队尾指针指向队尾元素：判空：<code>(Q.rear+1)%MaxSize==Q.front</code>。</p>
<p>​										  判满：1.牺牲一个存储单元。2.增加辅助变量（a.增加size变量记录队列长度。b.增加tag&#x3D;0&#x2F;1用于标记最近													  的一次操作是出队&#x2F;入队。）。</p>
</li>
<li><p>链队列：<strong>链式存储实现的队列</strong></p>
<p><strong>带头节点</strong>：初始化：<code>Q.front-&gt;next=NULL</code>。</p>
<p>​					判空：<code>Q.front==Q.rear</code>。</p>
<p>​					入队：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LinkNode * s=(LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">  s-&gt;data=x;</span><br><span class="line">s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">  Q.rear-&gt;next=s;		<span class="comment">//新节点插入到rear之后</span></span><br><span class="line">  Q.rear=s;			<span class="comment">//修改表尾指针</span></span><br></pre></td></tr></table></figure>

<p>​					出队：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(Q.front == NULL)</span><br><span class="line">	return false;				//空队</span><br><span class="line">LinkNode *p=Q.front-&gt;next;		</span><br><span class="line">x=p-&gt;data;						//用变量x返回队头元素</span><br><span class="line">Q.front-&gt;next=p-&gt;next;			//修改头节点的next指针</span><br><span class="line">if(Q.rear==p)&#123;					//此次是最后一个节点出队</span><br><span class="line">	Q.rear = Q.front;			//修改rear指针</span><br><span class="line">&#125;</span><br><span class="line">free(p);						//释放节点空间</span><br><span class="line">return true;</span><br></pre></td></tr></table></figure>

<p>​					队列满的条件：一般不会队满，除非内存空间不足。</p>
<p><strong>不带头节点</strong>：初始化：<code>Q.front=NULL;Q.rear=NULL</code>。</p>
<p>​					   判空：<code>Q.front==NULL</code>。</p>
<p>​					   入队：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LinkNode * s=(LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">s-&gt;data=x;</span><br><span class="line">s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(Q.front == <span class="literal">NULL</span>)&#123;	<span class="comment">//在空队列中插入第一个元素</span></span><br><span class="line">    Q.front = s;		<span class="comment">//修改队头队尾指针</span></span><br><span class="line">    Q.rear = s;</span><br><span class="line">&#125;</span><br><span class="line">Q.rear-&gt;next=s;		</span><br><span class="line">Q.rear=s;			</span><br></pre></td></tr></table></figure>

<p>​						出队：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(Q.front == NULL)</span><br><span class="line">	return false;			//空队</span><br><span class="line">LinkNode *p=Q.front;		//p指向此次出队的节点</span><br><span class="line">x=p-&gt;data;					//用变量x返回队头元素</span><br><span class="line">Q.front=p-&gt;next;			//修改front指针</span><br><span class="line">if(Q.rear==p)&#123;				//此次是最后一个节点出队</span><br><span class="line">	Q.front = NULL;			//front指向NULL</span><br><span class="line">	Q.rear = NULL;			//rear指向NULL</span><br><span class="line">&#125;</span><br><span class="line">free(p);					//释放节点空间</span><br><span class="line">return true;</span><br></pre></td></tr></table></figure>

<p>​						队列满的条件：（同上）</p>
</li>
</ul>
<h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><ul>
<li><strong>双端队列</strong>：只允许从两端插入、两端删除的线性表。</li>
<li><strong>输入受限的双端队列</strong>：只允许从一端插入、两端删除的线性表。</li>
<li><strong>输出受限的双端队列</strong>：只允许从两端插入、一端删除的线性表。</li>
<li>对输出序列合法性的判断：在栈中合法的输出序列，在双端队列中必定合法。</li>
</ul>
<h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><ul>
<li><p>括号匹配：遇到左括号就入栈，遇到右括号就“消耗”一个左括号（出栈）。</p>
<p>右括号单身：扫描到右括号且栈空。</p>
<p>左括号单身：处理完所有括号后，栈非空。</p>
</li>
<li><p>表达式求值：</p>
<p>​	三种算术表达式（由操作数、运算符、界限符组成，界限符只在中缀表达式出现）：中缀表达式（运算符在两个操作数中间）、后缀表达式（运算符在两个操作数后面）、前缀表达式（运算符在两个操作数前面）。</p>
<p>​	<strong>中缀转后缀的<u>手算</u>方法</strong>：（运算顺序不唯一，因此对应的后缀表达式也不唯一。）</p>
<ol>
<li>确定中缀表达式中各个运算符的运算顺序。</li>
<li>选择下一个运算符，按照【<strong>左操作数 右操作数 运算符</strong>】的方式组合成一个新的操作数。</li>
<li>如果还有运算符没被处理，就继续（2）。</li>
<li>“左优先”原则：只要左边的运算符能先计算，就优先算左边的，以保证手算和机算结果相同。</li>
</ol>
<p>​    <strong>后缀表达式的<u>手算</u>方法</strong>：从左往右扫描，没遇到一个运算符，就让运算符前面最近的两个操作数执行对应运算，合体为一个操作数，注意两个操作数的左右顺序。</p>
<p>​	<strong>用栈实现后缀表达式的计算</strong>：（若表达式合法，则最后栈中只会留下一个元素，就是最终结果。）</p>
<ol>
<li>从<strong>左往右</strong>扫描下一个元素，直到处理完所有元素。</li>
<li>若扫描到操作数则压入栈，并回到（1）；否则执行（3）。</li>
<li>若扫描到运算符，则弹出两个栈顶元素，执行相应运算（注意：<strong>先出栈的是右操作数</strong>），运算结果压回栈顶，回到（1）。</li>
</ol>
<p>​    <strong>中缀转前缀的<u>手算</u>方法</strong>：（运算顺序不唯一，因此对应的后缀表达式也不唯一。除非按“右优先”原则。）</p>
<ol>
<li>确定中缀表达式中各个运算符的运算顺序。</li>
<li>选择下一个运算符，按照【<strong>运算符 左操作数 右操作数</strong>】的方式组合成一个新的操作数。</li>
<li>如果还有运算符没被处理，就继续（2）。</li>
<li>“右优先”原则：只要右边的运算符能先计算，就优先算右边的，以保证手算和机算结果相同。</li>
</ol>
<p>​	<strong>用栈实现前缀表达式的计算</strong>：（若表达式合法，则最后栈中只会留下一个元素，就是最终结果。除非按“左优先”原则。）</p>
<ol>
<li>从<strong>右往左</strong>扫描下一个元素，直到处理完所有元素。</li>
<li>若扫描到操作数则压入栈，并回到（1）；否则执行（3）。</li>
<li>若扫描到运算符，则弹出两个栈顶元素，执行相应运算（注意：<strong>先出栈的是左操作数</strong>），运算结果压回栈顶，回到（1）。</li>
</ol>
<p>​    <strong>中缀表达式转后缀表达式的<u>机算</u>方法</strong>：</p>
<p>​	初始化一个栈用于保存暂时还不能确定运算顺序的运算符。从左到右处理各个元素，直到末尾。可能遇到三种情况：</p>
<ol>
<li>遇到<strong>操作数</strong>：直接加入后缀表达式。</li>
<li><strong>遇到界限符</strong>：遇到“（”直接入栈；遇到“）”则依次弹出栈内运算符并加入后缀表达式，直到弹出“（”为止。注意：“（”不加入后缀表达式。</li>
<li><strong>遇到运算符</strong>：依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到“（”或栈空则停止。之后再把当前运算符入栈。</li>
</ol>
<p>​    按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。</p>
<p>​	<strong>用栈实现中缀表达式的机算</strong>：</p>
<ol>
<li>初始化两个栈，<strong>操作数栈</strong>和<strong>运算符栈</strong>。</li>
<li>若扫描到操作数，则压入操作数栈。</li>
<li>若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈（期间也会弹出运算符，<strong>每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈</strong>。）</li>
</ol>
</li>
<li><p>递归（由递归体，递归出口组成）应用：</p>
<p>函数调用的特点：最后被调用的函数最先执行结束（LIFO）。</p>
<p>函数调用时，需要用一个栈存储：调用返回值；实参；局部变量。</p>
<p>适合用“递归”算法解决：可以把原始问题转换为属性相同，但规模较小的问题。</p>
<p>递归调用时，函数调用栈可称为“递归工作栈”。每进入一层递归，就将递归调用所需信息压入栈顶；每退出一层递归，就从栈顶弹出相应信息。</p>
<p>缺点：太多层递归可能会导致栈溢出；可能包含很多重复机算。递归算法的空间复杂度也会更高（效率低）。</p>
</li>
</ul>
<h2 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h2><ul>
<li>树的层次遍历</li>
<li>图的广度优先遍历</li>
<li>在操作系统中的应用，先来先服务（FCFS）</li>
<li>打印机，缓冲区用队列组织打印数据，可缓解主机与打印机速度不匹配的问题。</li>
</ul>
<h2 id="特殊矩阵的压缩存储"><a href="#特殊矩阵的压缩存储" class="headerlink" title="特殊矩阵的压缩存储"></a>特殊矩阵的压缩存储</h2><ul>
<li><p>二维数组的存储结构：分行优先存储和列优先存储。</p>
<p>M行N列的二维数组<code>b[M][N]</code>中，若按行优先存储，则<code>b[i][j]</code>的存储地址&#x3D;LOC + (i * N + j) * sizeof(ElemType)</p>
<p>​														 若按列优先存储，则<code>b[i][j]</code>的存储地址&#x3D;LOC + (j * M + i) * sizeof(ElemType)</p>
<p>LOC是起始地址。</p>
</li>
<li><p>注意：描述矩阵元素时，行、列号通常从1开始；而描述数组时通常下标从0开始。</p>
</li>
<li><p><strong>对称矩阵的压缩存储</strong>：①只存储主对角线+下三角区。按行优先原则将各元素存入一维数组中。</p>
<p>​										②按列优先原则，a(i,j)&#x3D;a(j,i)，同上。</p>
</li>
<li><p><strong>三角矩阵的压缩存储</strong>：按行优先原则将上三角或下三角区元素存入一维数组中。并在最后一个位置存储常量C。</p>
</li>
<li><p><strong>三对角矩阵（带状矩阵）的压缩存储</strong>：当|i-j|&gt;1时，有a(i,j)&#x3D;0是带状矩阵。</p>
<p>按行优先（或列优先）原则，只存储带状部分。</p>
</li>
<li><p><strong>稀疏矩阵的压缩存储</strong>：非零元素远远少于矩阵元素的个数。</p>
<p>顺序存储——三元组&lt;行,列,值&gt;;</p>
<p>l链式存储——十字链表法</p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表</title>
    <url>/2023/09/13/%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><ul>
<li><p><strong>线性表</strong>是具有<strong>相同</strong>数据类型的n（n≧0）个数据元素的<strong>有限</strong>序列，其中n为表长，当n&#x3D;0时线性表是一个空表。若用L命名线性表，则其一般表示为L&#x3D;（α₁,α₂…,α(n)）。</p>
</li>
<li><p>α(i)是线性表中的“第i个”元素，i是线性表中的<strong>位序</strong>。（注：位序从1开始，数组下标从0开始）</p>
</li>
<li><p>α₁是表头元素；α(n)是表尾元素。</p>
</li>
<li><p>除第一个元素外，每个元素有且仅有一个<strong>直接前驱</strong>；除最后一个元素外，每个元素有且仅有一个<strong>直接后继</strong>。</p>
</li>
<li><p>线性表的基本操作：</p>
<p><strong>InitList(&amp;L):初始化表</strong>。构造一个空的线性表L，分配内存空间。</p>
<p><strong>DestroyList(&amp;L):销毁操作</strong>。销毁线性表，并释放线性表L所占用的内存空间。</p>
<p><strong>ListInsert(&amp;L,i,e):插入操作</strong>。在表L中的第i个位置上插入指定元素e。</p>
<p><strong>ListDelete(&amp;L,i,&amp;e):删除操作</strong></p>
<p><strong>LocateElem(L,e):按值查找操作</strong></p>
<p><strong>GetElem(L,i):按位查找操作</strong>。时间复杂度是O(1)。</p>
</li>
</ul>
<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><ul>
<li><p><strong>顺序表</strong>——用<strong>顺序存储</strong>的方式实现线性表（逻辑上相邻的元素存储在物理位置上也相邻的存储单元中）。</p>
<p>优点：可随机存取，存储密度高。</p>
<p>缺点：要求大片连续空间，改变容量不方便。</p>
</li>
<li><p>顺序表的实现：</p>
<p><strong>静态分配</strong>（使用“静态数组”实现，表长刚开始确定后就无法更改，存储空间是静态的）</p>
<p><strong>动态分配</strong>（可用malloc动态拓展顺序表的最大容量，需要将数据元素复制到新的存储区域，并用free函数释放原区域）</p>
</li>
<li><p>顺序表的特点：</p>
<p><strong>随机访问</strong>，即可在O(1)时间内找到第i个元素。</p>
<p>存储密度高，每个节点只存储数据元素。</p>
<p>拓展容量不方便（即便采用动态分配的方式，拓展长度的时间复杂度也比较高）</p>
<p>插入、删除操作不方便，需要移动大量元素。</p>
</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul>
<li><p><strong>单链表</strong>——用链式存储的方式实现（每个节点除了存放数据元素外，还要存储指向下一个节点的指针）。</p>
<p>​					表尾节点的next指针指向NULL。</p>
<p>优点：不要求大片连续空间，改变容量方便。</p>
<p>缺点：不可随机存取，要耗费一定空间存放指针。</p>
<p>​			无法逆向检索，有时候不太方便。</p>
<p>两种实现：</p>
<p>​		1.不带头节点（空表判断：<code>L==NULL</code>写代码不方便）</p>
<p>​		2.带头节点（空表判断：<code>L-&gt;next==NULL</code>写代码更方便）</p>
<p>单链表的建立：</p>
<p>​		头插法、尾插法：核心就是初始化操作、指定节点的后插操作。</p>
<p>​		（头插法的重要应用：链表的逆置）</p>
</li>
<li><p><strong>双链表</strong>——（用法同上）。</p>
<p>​					表头节点的prior指向NULL，表尾节点的next指向NULL。</p>
<p>对比单链表：可进可退，存储密度更低一丢丢。</p>
</li>
<li><p><strong>循环链表</strong></p>
<p>循环单链表——表尾节点的next指针指向头节点。（空表判断：L-&gt;next&#x3D;&#x3D;L）</p>
<p>循环双链表——表头节点的prior指向表尾节点；表尾节点的next指向头节点。（空表判断：L-&gt;next&#x3D;&#x3D;L）</p>
</li>
<li><p><strong>静态链表</strong>——分配一整片连续的内存空间，各个节点集中安置。</p>
<p>​						0号节点充当“头节点”。</p>
<p>​						<strong>游标</strong>充当指针（下一个节点的数组下标）。</p>
<p>​						游标为**-1**表示已经到达表尾。</p>
<p>优点：增、删操作不需要大量移动元素，只需改动相应元素的游标即可。</p>
<p>缺点：不能随机存取，只能从头节点开始依次往后查找，且容量固定不可变。</p>
<p>定义方式：可用结构体数组定义一片连续存放的区域。</p>
<p>适用场景：1.不支持指针的低级语言。</p>
<p>​					2.数据元素量固定不变的场景（如操作系统的文件分配表FAT）。</p>
</li>
</ul>
<h2 id="顺序表与链表的比较"><a href="#顺序表与链表的比较" class="headerlink" title="顺序表与链表的比较"></a>顺序表与链表的比较</h2><table>
<thead>
<tr>
<th align="left"></th>
<th>顺序表</th>
<th>链表</th>
</tr>
</thead>
<tbody><tr>
<td align="left">逻辑结构</td>
<td>都属于线性表，都是线性结构。</td>
<td>（同上）</td>
</tr>
<tr>
<td align="left">存储结构</td>
<td>优点：支持随机存取、存储密度高<br />缺点：大片连续空间分配不方便，改变容量不方便</td>
<td>优点：离散的小空间分配方便，改变容量方便<br />缺点：不可随机存取，存储密度低</td>
</tr>
<tr>
<td align="left">基本操作</td>
<td><strong>创</strong>：需要预分配大片连续空间。若分配空间过小，则之后不方便拓展容量；若分配空间过大，则浪费内存资源。<br />（静态分配：静态数组，容量不可改变。<br /> 动态分配：动态数组，容量可改变，但需要移动大量元素，时间代价高。）<br /><strong>销</strong>：修改Length&#x3D;0。<br />（静态分配：静态数组，系统自动回收空间。<br />动态分配：动态数组，需要手动free。）<br /><strong>增&#x2F;删</strong>：插入&#x2F;删除元素要将后续元素都后移&#x2F;前移，时间复杂度O(n)，时间开销主要来自移动元素。（若数据元素很大，则移动的时间代价很高）<br /><strong>查</strong>：按位查找：O(1)<br />按值查找：O(n) ，若表内元素有序，可在O(㏒₂n)时间内找到。</td>
<td><strong>创</strong>：只需分配一个头节点（也可以不要头节点，只声明一个头指针），之后方便拓展。<br /><strong>销</strong>：依次删除各个节点（free）。<br /><strong>增&#x2F;删</strong>：插入&#x2F;删除元素只需修改指针即可，时间复杂度O(n)，时间开销主要来查找目标元素。（查找元素的时间代价更低）<br /><strong>查</strong>：按位查找：O(n)<br />按值查找：O(n)</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2023/09/17/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>



<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; numsSize; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                <span class="type">int</span>* ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">2</span>);</span><br><span class="line">                ret[<span class="number">0</span>] = i, ret[<span class="number">1</span>] = j;</span><br><span class="line">                *returnSize = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>相交链表</title>
    <url>/2023/09/18/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p>
<p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p>
<p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></a></p>
<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>
<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>
<p><strong>自定义评测：</strong></p>
<p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p>
<ul>
<li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li>
<li><code>listA</code> - 第一个链表</li>
<li><code>listB</code> - 第二个链表</li>
<li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li>
<li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li>
</ul>
<p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Intersected at &#x27;8&#x27;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br><span class="line">— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Intersected at &#x27;2&#x27;</span><br><span class="line">解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class="line">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure>



<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode *<span class="title function_">getIntersectionNode</span><span class="params">(<span class="keyword">struct</span> ListNode *headA, <span class="keyword">struct</span> ListNode *headB)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">i</span> =</span> headA, *j = headB;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>, len1 = <span class="number">0</span>, len2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len1++;</span><br><span class="line">        i = i-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len2++;</span><br><span class="line">        j = j-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    i = headA, j = headB;</span><br><span class="line">    <span class="keyword">if</span>(len1 &gt; len2)</span><br><span class="line">    &#123;</span><br><span class="line">        len = len1 - len2;</span><br><span class="line">        <span class="keyword">while</span>(len--)</span><br><span class="line">            i = i-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len1 &lt; len2)</span><br><span class="line">    &#123;</span><br><span class="line">        len = len2 - len1;</span><br><span class="line">        <span class="keyword">while</span>(len--)</span><br><span class="line">            j = j-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == j)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i = i-&gt;next;</span><br><span class="line">            j = j-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索插入位置</title>
    <url>/2023/09/17/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">	<span class="type">int</span> low = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> high = numsSize<span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> mid = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">	&#123;</span><br><span class="line">		mid = low + (high-low) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">		&#123;</span><br><span class="line">			high = mid <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(low&gt;high)</span><br><span class="line">                <span class="keyword">return</span> high+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(low&gt;high)</span><br><span class="line">                <span class="keyword">return</span> low;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>交替合并字符串</title>
    <url>/2023/09/20/%E4%BA%A4%E6%9B%BF%E5%90%88%E5%B9%B6%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>给你两个字符串 <code>word1</code> 和 <code>word2</code> 。请你从 <code>word1</code> 开始，通过交替添加字母来合并字符串。如果一个字符串比另一个字符串长，就将多出来的字母追加到合并后字符串的末尾。</p>
<p>返回 <strong>合并后的字符串</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：word1 = &quot;abc&quot;, word2 = &quot;pqr&quot;</span><br><span class="line">输出：&quot;apbqcr&quot;</span><br><span class="line">解释：字符串合并情况如下所示：</span><br><span class="line">word1：  a   b   c</span><br><span class="line">word2：    p   q   r</span><br><span class="line">合并后：  a p b q c r</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：word1 = &quot;ab&quot;, word2 = &quot;pqrs&quot;</span><br><span class="line">输出：&quot;apbqrs&quot;</span><br><span class="line">解释：注意，word2 比 word1 长，&quot;rs&quot; 需要追加到合并后字符串的末尾。</span><br><span class="line">word1：  a   b </span><br><span class="line">word2：    p   q   r   s</span><br><span class="line">合并后：  a p b q   r   s</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：word1 = &quot;abcd&quot;, word2 = &quot;pq&quot;</span><br><span class="line">输出：&quot;apbqcd&quot;</span><br><span class="line">解释：注意，word1 比 word2 长，&quot;cd&quot; 需要追加到合并后字符串的末尾。</span><br><span class="line">word1：  a   b   c   d</span><br><span class="line">word2：    p   q </span><br><span class="line">合并后：  a p b q c   d</span><br></pre></td></tr></table></figure>





<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> * <span class="title function_">mergeAlternately</span><span class="params">(<span class="type">char</span> * word1, <span class="type">char</span> * word2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> len1=<span class="built_in">strlen</span>(word1);</span><br><span class="line">    <span class="type">int</span> len2=<span class="built_in">strlen</span>(word2);</span><br><span class="line">    <span class="type">char</span> *word3=(<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*(len1+len2+<span class="number">1</span>));</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;len1 || i&lt;len2;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;len1)  word3[j++]=word1[i];</span><br><span class="line">        <span class="keyword">if</span>(i&lt;len2)  word3[j++]=word2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    word3[j]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> word3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>找不同</title>
    <url>/2023/09/20/%E6%89%BE%E4%B8%8D%E5%90%8C/</url>
    <content><![CDATA[<p>给定两个字符串 <code>s</code> 和 <code>t</code> ，它们只包含小写字母。</p>
<p>字符串 <code>t</code> 由字符串 <code>s</code> 随机重排，然后在随机位置添加一个字母。</p>
<p>请找出在 <code>t</code> 中被添加的字母。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abcd&quot;, t = &quot;abcde&quot;</span><br><span class="line">输出：&quot;e&quot;</span><br><span class="line">解释：&#x27;e&#x27; 是那个被添加的字母。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;&quot;, t = &quot;y&quot;</span><br><span class="line">输出：&quot;y&quot;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="title function_">findTheDifference</span><span class="params">(<span class="type">char</span> * s, <span class="type">char</span> * t)</span>&#123;</span><br><span class="line">    <span class="type">int</span> as = <span class="number">0</span>, at = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*s)</span><br><span class="line">        as += (*s++);</span><br><span class="line">    <span class="keyword">while</span> (*t)</span><br><span class="line">        at += (*t++);</span><br><span class="line">    <span class="keyword">return</span> at - as;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>在区间范围内统计奇数数目</title>
    <url>/2023/09/19/%E5%9C%A8%E5%8C%BA%E9%97%B4%E8%8C%83%E5%9B%B4%E5%86%85%E7%BB%9F%E8%AE%A1%E5%A5%87%E6%95%B0%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<p>给你两个非负整数 <code>low</code> 和 <code>high</code> 。请你返回 <code>low</code> 和 <code>high</code> 之间（包括二者）奇数的数目。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：low = 3, high = 7</span><br><span class="line">输出：3</span><br><span class="line">解释：3 到 7 之间奇数数字为 [3,5,7] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：low = 8, high = 10</span><br><span class="line">输出：1</span><br><span class="line">解释：8 到 10 之间奇数数字为 [9] 。</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">countOdds</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low%<span class="number">2</span> == <span class="number">0</span> &amp;&amp; high%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (high-low)/<span class="number">2</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(low%<span class="number">2</span> == <span class="number">1</span> || high%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (high-low)/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>爬楼梯</title>
    <url>/2023/09/19/%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶</span><br><span class="line">2. 2 阶</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶 + 1 阶</span><br><span class="line">2. 1 阶 + 2 阶</span><br><span class="line">3. 2 阶 + 1 阶</span><br></pre></td></tr></table></figure>



<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="type">int</span> num[n+<span class="number">1</span>];</span><br><span class="line">    num[<span class="number">0</span>]=<span class="number">1</span>,num[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        num[i]=num[i<span class="number">-1</span>]+num[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>移动零</title>
    <url>/2023/09/17/%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0]</span><br><span class="line">输出: [0]</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;numsSize;i++)   <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)  nums[j++]=nums[i];</span><br><span class="line">    <span class="keyword">for</span>(i=j;i&lt;numsSize;i++) nums[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>

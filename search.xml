<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>这是一篇新文章</title>
    <url>/2023/09/09/test/</url>
    <content><![CDATA[<p>新文章测试。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>数据结构</tag>
        <tag>英格培训</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/08/28/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2023/09/12/%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li><strong>数据对象</strong>是具有相同<u>性质</u>的数据元素的集合，是数据的一个子集。</li>
<li><strong>数据结构</strong>是相互之间存在一种或多种特定<u>关系</u>的数据元素的集合。</li>
<li>同样的数据元素可组成不同的数据结构，不同的数据元素可组成相同的数据结构。</li>
</ul>
<h2 id="数据结构的三要素"><a href="#数据结构的三要素" class="headerlink" title="数据结构的三要素"></a>数据结构的三要素</h2><ul>
<li><p><strong>逻辑结构</strong>：</p>
<p>集合结构：（各个元素同属一个集合，别无其它关系。）</p>
<p>线性结构：一对一（除了第一个元素，所有元素都有唯一前驱；除了最后一个元素，所有元素都有唯一后继。）</p>
<p>树形结构：一对多</p>
<p>图状结构：多对多</p>
</li>
<li><p><strong>数据的运算</strong>：针对于某种逻辑结构，结合实际需求，定义基本运算。</p>
</li>
<li><p><strong>物理结构（存储结构）</strong>： </p>
<p>顺序存储（逻辑上相邻的元素存储在物理位置上也相邻的存储单元中。）</p>
<p>链式存储（逻辑上相邻的元素在物理位置上可以不相邻。）</p>
<p>索引存储（在存储元素信息的同时，还建立附加的<u>索引表</u>。索引表中的每项称为索引项，索引项的一般形 式是（关键字，地址）。）</p>
<p>散列存储（根据元素的关键字直接计算出该元素的存储地址，又称<u>哈希存储</u>。）</p>
<p>注：除了顺序存储其他的都是非顺序存储（离散存储）。</p>
<p>​		数据的存储结构会影响存储空间分配的方便程度。</p>
<p>​		数据的存储结构会影响对数据运算的速度。</p>
<p>​		运算的定义是针对逻辑结构的，运算的实现是针对存储结构的。</p>
</li>
</ul>
<h2 id="数据类型、抽象数据类型"><a href="#数据类型、抽象数据类型" class="headerlink" title="数据类型、抽象数据类型"></a>数据类型、抽象数据类型</h2><ul>
<li><p><strong>数据类型</strong>是一个值的集合和定义在此集合上的一组操作的总称。</p>
<p>原子类型：其值不可再分的数据类型。</p>
<p>结构类型：其值可以再分解为若干成分的数据类型。</p>
</li>
<li><p><strong>抽象数据类型（ADT）</strong>是抽象数据组织及与之相关的操作。</p>
</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul>
<li><p><strong>算法</strong>是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。</p>
</li>
<li><p><strong>算法的五个特性</strong></p>
<p>有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。（注：算法必须是有穷的，而程序可以是无穷的。）</p>
<p>确定性：算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。</p>
<p>可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。</p>
<p>输入：一个算法有零个或多个输入。</p>
<p>输出：一个算法有一个或多个输出。</p>
</li>
<li><p><strong>“好”算法</strong>的特性：正确性、可读性、健壮性、高效率与低存储量需求。</p>
</li>
<li><p><strong>时间复杂度</strong>:衡量时间开销与问题规模n之间的关系。（以最深层的for循环为主）</p>
<p><strong>O(1)&lt;O(㏒₂n)&lt;O(n)&lt;O(n㏒₂n)&lt;O(n²)&lt;O(n³)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)</strong></p>
<p>加法规则：T(n)&#x3D;O(f(n))+O(g(n))&#x3D;O(max(f(n),g(n)))</p>
<p>乘法规则：T(n)&#x3D;O(f(n))×O(g(n))&#x3D;O(f(n)×g(n))</p>
</li>
<li><p><strong>空间复杂度</strong>：空间开销（内存开销）与问题规模n之间的关系。（以最高维的数组为主或者等于递归调用的深度）</p>
<p>算法<strong>原地工作</strong>——算法所需内存空间为常量</p>
<p>（用法同上。）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2023/09/15/%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul>
<li><p><strong>栈</strong>是只允许在一端进行插入或者删除操作的<strong>线性表</strong>。</p>
</li>
<li><p><strong>栈顶</strong>：允许插入和删除的一端。</p>
<p><strong>栈底</strong>：不允许插入和删除的一端。</p>
<p><strong>空栈</strong>：空表。</p>
</li>
<li><p>特点：<strong>先进后出</strong>（LIFO）</p>
</li>
<li><p>基本操作：</p>
<p>InitStack(&amp;S):初始化栈。构造一个空栈S，分配内存空间。</p>
<p>DestroyStack(&amp;L):销毁栈。销毁并释放栈S所占用的内存空间。</p>
<p>Push(&amp;S,x):进栈。若栈S未满，则将x加入使之成为新栈顶。</p>
<p>Pop(&amp;S,&amp;x):出栈。若栈S非空，则弹出栈顶元素，并用x返回。</p>
<p>其他常用操作：</p>
<p>StackEmpty(S):判断一个栈S是否为空。若S为空，则返回true，否则返回false。</p>
</li>
<li><p>n个不同的元素进栈，出栈元素不同排列的个数为(1&#x2F;(n+1))C(2n下标，n上标)。（卡特兰数）</p>
</li>
<li><p><strong>顺序栈</strong>：用顺序存储方式实现的栈。</p>
<p>定义操作：静态数组存放栈中的元素；栈顶指针。</p>
<p>（顺序存储：给各个数据元素分配连续的存储空间，大小为MaxSize * sizeof(ElemType)。）</p>
<p>进栈操作：<code>S.data[++S.top]=x</code>。</p>
<p>出栈操作：<code>x=S.data[S.top--]</code>。</p>
<p>读栈操作：<code>x=S.data[S.top-1]</code>。</p>
<p>栈满的条件：<code>top==MaxSize</code>。</p>
<p>顺序栈的缺点：栈的大小不可变。</p>
</li>
<li><p><strong>共享栈</strong>：两个栈共享同一片空间。</p>
<p>需要两个栈顶指针，分别从内存两端向内填数据。（<code>S.top0=-1；S.top1=MaxSize</code>）</p>
<p>栈满条件：<code>top0 + 1 == top1</code>。</p>
</li>
<li><p><strong>链栈</strong>：用链式存储方式实现的栈。</p>
<p>用法跟链表基本一致，只是进栈&#x2F;出栈都只能在栈顶一端进行（链头作为栈顶）。</p>
</li>
</ul>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ul>
<li><p><strong>队列</strong>是只允许在一端进行插入，在另一端删除的<strong>线性表</strong>。</p>
</li>
<li><p><strong>队头</strong>：运行删除的一端。</p>
<p><strong>队尾</strong>：允许插入的一端。</p>
<p><strong>空队列</strong>：空表。</p>
</li>
<li><p>特点：<strong>先进先出</strong>（FIFO）</p>
</li>
<li><p>基本操作：</p>
<p>InitQueue(&amp;Q):初始化队列。构造一个空队列Q，分配内存空间。</p>
<p>DestroyQueue(&amp;Q):销毁队列。销毁并释放队列Q所占用的内存空间。</p>
<p>EnQueue(&amp;Q,x):入队。若队列Q未满，则将x加入使之成为新队尾。</p>
<p>DeQueue(&amp;Q,&amp;x):出队。若队列Q非空，删除队头元素，并用x返回。</p>
<p>GetHead(Q,&amp;x):读队头元素，若队列Q非空，则将队头元素赋值给x。</p>
<p>其他常用操作：</p>
<p>QueueEmpty(Q):判断一个队列Q是否为空。若Q为空，则返回true，否则返回false。</p>
</li>
<li><p><strong>队列的顺序实现</strong>：</p>
<p>定义操作：用静态数组存放队列元素，还应有队头指针（front）和队尾指针（rear）（指向队尾元素的后一个位置）。</p>
<p>判空操作：<code>Q.rear==Q.front</code>。</p>
<p>入队操作：<code>Q.rear=(Q.rear+1)%MaxSize</code> 可以将存储空间在逻辑上变成了“环状”。（<strong>循环队列</strong>）</p>
<p>​					队列已满的条件：队尾指针的再下一个位置是队头，即(Q.rear+1)%MaxSize&#x3D;&#x3D;Q.front。（代价：牺牲一个存储单元。）</p>
<p>出队操作：<code>Q.front=(Q.front+1)%MaxSize</code>  队头指针后移。</p>
<p>查找操作：<code>x=Q.data[Q.front]</code>。</p>
<p><strong>队列元素个数</strong>：(rear+MaxSize-front)%MaxSize。</p>
<p>队尾指针指向队尾元素：判空：<code>(Q.rear+1)%MaxSize==Q.front</code>。</p>
<p>​										  判满：1.牺牲一个存储单元。2.增加辅助变量（a.增加size变量记录队列长度。b.增加tag&#x3D;0&#x2F;1用于标记最近													  的一次操作是出队&#x2F;入队。）。</p>
</li>
<li><p>链队列：<strong>链式存储实现的队列</strong></p>
<p><strong>带头节点</strong>：初始化：<code>Q.front-&gt;next=NULL</code>。</p>
<p>​					判空：<code>Q.front==Q.rear</code>。</p>
<p>​					入队：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LinkNode * s=(LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">  s-&gt;data=x;</span><br><span class="line">s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">  Q.rear-&gt;next=s;		<span class="comment">//新节点插入到rear之后</span></span><br><span class="line">  Q.rear=s;			<span class="comment">//修改表尾指针</span></span><br></pre></td></tr></table></figure>

<p>​					出队：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(Q.front == NULL)</span><br><span class="line">	return false;				//空队</span><br><span class="line">LinkNode *p=Q.front-&gt;next;		</span><br><span class="line">x=p-&gt;data;						//用变量x返回队头元素</span><br><span class="line">Q.front-&gt;next=p-&gt;next;			//修改头节点的next指针</span><br><span class="line">if(Q.rear==p)&#123;					//此次是最后一个节点出队</span><br><span class="line">	Q.rear = Q.front;			//修改rear指针</span><br><span class="line">&#125;</span><br><span class="line">free(p);						//释放节点空间</span><br><span class="line">return true;</span><br></pre></td></tr></table></figure>

<p>​					队列满的条件：一般不会队满，除非内存空间不足。</p>
<p><strong>不带头节点</strong>：初始化：<code>Q.front=NULL;Q.rear=NULL</code>。</p>
<p>​					   判空：<code>Q.front==NULL</code>。</p>
<p>​					   入队：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LinkNode * s=(LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">s-&gt;data=x;</span><br><span class="line">s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(Q.front == <span class="literal">NULL</span>)&#123;	<span class="comment">//在空队列中插入第一个元素</span></span><br><span class="line">    Q.front = s;		<span class="comment">//修改队头队尾指针</span></span><br><span class="line">    Q.rear = s;</span><br><span class="line">&#125;</span><br><span class="line">Q.rear-&gt;next=s;		</span><br><span class="line">Q.rear=s;			</span><br></pre></td></tr></table></figure>

<p>​						出队：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(Q.front == NULL)</span><br><span class="line">	return false;			//空队</span><br><span class="line">LinkNode *p=Q.front;		//p指向此次出队的节点</span><br><span class="line">x=p-&gt;data;					//用变量x返回队头元素</span><br><span class="line">Q.front=p-&gt;next;			//修改front指针</span><br><span class="line">if(Q.rear==p)&#123;				//此次是最后一个节点出队</span><br><span class="line">	Q.front = NULL;			//front指向NULL</span><br><span class="line">	Q.rear = NULL;			//rear指向NULL</span><br><span class="line">&#125;</span><br><span class="line">free(p);					//释放节点空间</span><br><span class="line">return true;</span><br></pre></td></tr></table></figure>

<p>​						队列满的条件：（同上）</p>
</li>
</ul>
<h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><ul>
<li><strong>双端队列</strong>：只允许从两端插入、两端删除的线性表。</li>
<li><strong>输入受限的双端队列</strong>：只允许从一端插入、两端删除的线性表。</li>
<li><strong>输出受限的双端队列</strong>：只允许从两端插入、一端删除的线性表。</li>
<li>对输出序列合法性的判断：在栈中合法的输出序列，在双端队列中必定合法。</li>
</ul>
<h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><ul>
<li><p>括号匹配：遇到左括号就入栈，遇到右括号就“消耗”一个左括号（出栈）。</p>
<p>右括号单身：扫描到右括号且栈空。</p>
<p>左括号单身：处理完所有括号后，栈非空。</p>
</li>
<li><p>表达式求值：</p>
<p>​	三种算术表达式（由操作数、运算符、界限符组成，界限符只在中缀表达式出现）：中缀表达式（运算符在两个操作数中间）、后缀表达式（运算符在两个操作数后面）、前缀表达式（运算符在两个操作数前面）。</p>
<p>​	<strong>中缀转后缀的<u>手算</u>方法</strong>：（运算顺序不唯一，因此对应的后缀表达式也不唯一。）</p>
<ol>
<li>确定中缀表达式中各个运算符的运算顺序。</li>
<li>选择下一个运算符，按照【<strong>左操作数 右操作数 运算符</strong>】的方式组合成一个新的操作数。</li>
<li>如果还有运算符没被处理，就继续（2）。</li>
<li>“左优先”原则：只要左边的运算符能先计算，就优先算左边的，以保证手算和机算结果相同。</li>
</ol>
<p>​    <strong>后缀表达式的<u>手算</u>方法</strong>：从左往右扫描，没遇到一个运算符，就让运算符前面最近的两个操作数执行对应运算，合体为一个操作数，注意两个操作数的左右顺序。</p>
<p>​	<strong>用栈实现后缀表达式的计算</strong>：（若表达式合法，则最后栈中只会留下一个元素，就是最终结果。）</p>
<ol>
<li>从<strong>左往右</strong>扫描下一个元素，直到处理完所有元素。</li>
<li>若扫描到操作数则压入栈，并回到（1）；否则执行（3）。</li>
<li>若扫描到运算符，则弹出两个栈顶元素，执行相应运算（注意：<strong>先出栈的是右操作数</strong>），运算结果压回栈顶，回到（1）。</li>
</ol>
<p>​    <strong>中缀转前缀的<u>手算</u>方法</strong>：（运算顺序不唯一，因此对应的后缀表达式也不唯一。除非按“右优先”原则。）</p>
<ol>
<li>确定中缀表达式中各个运算符的运算顺序。</li>
<li>选择下一个运算符，按照【<strong>运算符 左操作数 右操作数</strong>】的方式组合成一个新的操作数。</li>
<li>如果还有运算符没被处理，就继续（2）。</li>
<li>“右优先”原则：只要右边的运算符能先计算，就优先算右边的，以保证手算和机算结果相同。</li>
</ol>
<p>​	<strong>用栈实现前缀表达式的计算</strong>：（若表达式合法，则最后栈中只会留下一个元素，就是最终结果。除非按“左优先”原则。）</p>
<ol>
<li>从<strong>右往左</strong>扫描下一个元素，直到处理完所有元素。</li>
<li>若扫描到操作数则压入栈，并回到（1）；否则执行（3）。</li>
<li>若扫描到运算符，则弹出两个栈顶元素，执行相应运算（注意：<strong>先出栈的是左操作数</strong>），运算结果压回栈顶，回到（1）。</li>
</ol>
<p>​    <strong>中缀表达式转后缀表达式的<u>机算</u>方法</strong>：</p>
<p>​	初始化一个栈用于保存暂时还不能确定运算顺序的运算符。从左到右处理各个元素，直到末尾。可能遇到三种情况：</p>
<ol>
<li>遇到<strong>操作数</strong>：直接加入后缀表达式。</li>
<li><strong>遇到界限符</strong>：遇到“（”直接入栈；遇到“）”则依次弹出栈内运算符并加入后缀表达式，直到弹出“（”为止。注意：“（”不加入后缀表达式。</li>
<li><strong>遇到运算符</strong>：依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到“（”或栈空则停止。之后再把当前运算符入栈。</li>
</ol>
<p>​    按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。</p>
<p>​	<strong>用栈实现中缀表达式的机算</strong>：</p>
<ol>
<li>初始化两个栈，<strong>操作数栈</strong>和<strong>运算符栈</strong>。</li>
<li>若扫描到操作数，则压入操作数栈。</li>
<li>若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈（期间也会弹出运算符，<strong>每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈</strong>。）</li>
</ol>
</li>
<li><p>递归（由递归体，递归出口组成）应用：</p>
<p>函数调用的特点：最后被调用的函数最先执行结束（LIFO）。</p>
<p>函数调用时，需要用一个栈存储：调用返回值；实参；局部变量。</p>
<p>适合用“递归”算法解决：可以把原始问题转换为属性相同，但规模较小的问题。</p>
<p>递归调用时，函数调用栈可称为“递归工作栈”。每进入一层递归，就将递归调用所需信息压入栈顶；每退出一层递归，就从栈顶弹出相应信息。</p>
<p>缺点：太多层递归可能会导致栈溢出；可能包含很多重复机算。递归算法的空间复杂度也会更高（效率低）。</p>
</li>
</ul>
<h2 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h2><ul>
<li>树的层次遍历</li>
<li>图的广度优先遍历</li>
<li>在操作系统中的应用，先来先服务（FCFS）</li>
<li>打印机，缓冲区用队列组织打印数据，可缓解主机与打印机速度不匹配的问题。</li>
</ul>
<h2 id="特殊矩阵的压缩存储"><a href="#特殊矩阵的压缩存储" class="headerlink" title="特殊矩阵的压缩存储"></a>特殊矩阵的压缩存储</h2><ul>
<li><p>二维数组的存储结构：分行优先存储和列优先存储。</p>
<p>M行N列的二维数组<code>b[M][N]</code>中，若按行优先存储，则<code>b[i][j]</code>的存储地址&#x3D;LOC + (i * N + j) * sizeof(ElemType)</p>
<p>​														 若按列优先存储，则<code>b[i][j]</code>的存储地址&#x3D;LOC + (j * M + i) * sizeof(ElemType)</p>
<p>LOC是起始地址。</p>
</li>
<li><p>注意：描述矩阵元素时，行、列号通常从1开始；而描述数组时通常下标从0开始。</p>
</li>
<li><p><strong>对称矩阵的压缩存储</strong>：①只存储主对角线+下三角区。按行优先原则将各元素存入一维数组中。</p>
<p>​										②按列优先原则，a(i,j)&#x3D;a(j,i)，同上。</p>
</li>
<li><p><strong>三角矩阵的压缩存储</strong>：按行优先原则将上三角或下三角区元素存入一维数组中。并在最后一个位置存储常量C。</p>
</li>
<li><p><strong>三对角矩阵（带状矩阵）的压缩存储</strong>：当|i-j|&gt;1时，有a(i,j)&#x3D;0是带状矩阵。</p>
<p>按行优先（或列优先）原则，只存储带状部分。</p>
</li>
<li><p><strong>稀疏矩阵的压缩存储</strong>：非零元素远远少于矩阵元素的个数。</p>
<p>顺序存储——三元组&lt;行,列,值&gt;;</p>
<p>l链式存储——十字链表法</p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表</title>
    <url>/2023/09/13/%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><ul>
<li><p><strong>线性表</strong>是具有<strong>相同</strong>数据类型的n（n≧0）个数据元素的<strong>有限</strong>序列，其中n为表长，当n&#x3D;0时线性表是一个空表。若用L命名线性表，则其一般表示为L&#x3D;（α₁,α₂…,α(n)）。</p>
</li>
<li><p>α(i)是线性表中的“第i个”元素，i是线性表中的<strong>位序</strong>。（注：位序从1开始，数组下标从0开始）</p>
</li>
<li><p>α₁是表头元素；α(n)是表尾元素。</p>
</li>
<li><p>除第一个元素外，每个元素有且仅有一个<strong>直接前驱</strong>；除最后一个元素外，每个元素有且仅有一个<strong>直接后继</strong>。</p>
</li>
<li><p>线性表的基本操作：</p>
<p><strong>InitList(&amp;L):初始化表</strong>。构造一个空的线性表L，分配内存空间。</p>
<p><strong>DestroyList(&amp;L):销毁操作</strong>。销毁线性表，并释放线性表L所占用的内存空间。</p>
<p><strong>ListInsert(&amp;L,i,e):插入操作</strong>。在表L中的第i个位置上插入指定元素e。</p>
<p><strong>ListDelete(&amp;L,i,&amp;e):删除操作</strong></p>
<p><strong>LocateElem(L,e):按值查找操作</strong></p>
<p><strong>GetElem(L,i):按位查找操作</strong>。时间复杂度是O(1)。</p>
</li>
</ul>
<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><ul>
<li><p><strong>顺序表</strong>——用<strong>顺序存储</strong>的方式实现线性表（逻辑上相邻的元素存储在物理位置上也相邻的存储单元中）。</p>
<p>优点：可随机存取，存储密度高。</p>
<p>缺点：要求大片连续空间，改变容量不方便。</p>
</li>
<li><p>顺序表的实现：</p>
<p><strong>静态分配</strong>（使用“静态数组”实现，表长刚开始确定后就无法更改，存储空间是静态的）</p>
<p><strong>动态分配</strong>（可用malloc动态拓展顺序表的最大容量，需要将数据元素复制到新的存储区域，并用free函数释放原区域）</p>
</li>
<li><p>顺序表的特点：</p>
<p><strong>随机访问</strong>，即可在O(1)时间内找到第i个元素。</p>
<p>存储密度高，每个节点只存储数据元素。</p>
<p>拓展容量不方便（即便采用动态分配的方式，拓展长度的时间复杂度也比较高）</p>
<p>插入、删除操作不方便，需要移动大量元素。</p>
</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul>
<li><p><strong>单链表</strong>——用链式存储的方式实现（每个节点除了存放数据元素外，还要存储指向下一个节点的指针）。</p>
<p>​					表尾节点的next指针指向NULL。</p>
<p>优点：不要求大片连续空间，改变容量方便。</p>
<p>缺点：不可随机存取，要耗费一定空间存放指针。</p>
<p>​			无法逆向检索，有时候不太方便。</p>
<p>两种实现：</p>
<p>​		1.不带头节点（空表判断：<code>L==NULL</code>写代码不方便）</p>
<p>​		2.带头节点（空表判断：<code>L-&gt;next==NULL</code>写代码更方便）</p>
<p>单链表的建立：</p>
<p>​		头插法、尾插法：核心就是初始化操作、指定节点的后插操作。</p>
<p>​		（头插法的重要应用：链表的逆置）</p>
</li>
<li><p><strong>双链表</strong>——（用法同上）。</p>
<p>​					表头节点的prior指向NULL，表尾节点的next指向NULL。</p>
<p>对比单链表：可进可退，存储密度更低一丢丢。</p>
</li>
<li><p><strong>循环链表</strong></p>
<p>循环单链表——表尾节点的next指针指向头节点。（空表判断：L-&gt;next&#x3D;&#x3D;L）</p>
<p>循环双链表——表头节点的prior指向表尾节点；表尾节点的next指向头节点。（空表判断：L-&gt;next&#x3D;&#x3D;L）</p>
</li>
<li><p><strong>静态链表</strong>——分配一整片连续的内存空间，各个节点集中安置。</p>
<p>​						0号节点充当“头节点”。</p>
<p>​						<strong>游标</strong>充当指针（下一个节点的数组下标）。</p>
<p>​						游标为**-1**表示已经到达表尾。</p>
<p>优点：增、删操作不需要大量移动元素，只需改动相应元素的游标即可。</p>
<p>缺点：不能随机存取，只能从头节点开始依次往后查找，且容量固定不可变。</p>
<p>定义方式：可用结构体数组定义一片连续存放的区域。</p>
<p>适用场景：1.不支持指针的低级语言。</p>
<p>​					2.数据元素量固定不变的场景（如操作系统的文件分配表FAT）。</p>
</li>
</ul>
<h2 id="顺序表与链表的比较"><a href="#顺序表与链表的比较" class="headerlink" title="顺序表与链表的比较"></a>顺序表与链表的比较</h2><table>
<thead>
<tr>
<th align="left"></th>
<th>顺序表</th>
<th>链表</th>
</tr>
</thead>
<tbody><tr>
<td align="left">逻辑结构</td>
<td>都属于线性表，都是线性结构。</td>
<td>（同上）</td>
</tr>
<tr>
<td align="left">存储结构</td>
<td>优点：支持随机存取、存储密度高<br />缺点：大片连续空间分配不方便，改变容量不方便</td>
<td>优点：离散的小空间分配方便，改变容量方便<br />缺点：不可随机存取，存储密度低</td>
</tr>
<tr>
<td align="left">基本操作</td>
<td><strong>创</strong>：需要预分配大片连续空间。若分配空间过小，则之后不方便拓展容量；若分配空间过大，则浪费内存资源。<br />（静态分配：静态数组，容量不可改变。<br /> 动态分配：动态数组，容量可改变，但需要移动大量元素，时间代价高。）<br /><strong>销</strong>：修改Length&#x3D;0。<br />（静态分配：静态数组，系统自动回收空间。<br />动态分配：动态数组，需要手动free。）<br /><strong>增&#x2F;删</strong>：插入&#x2F;删除元素要将后续元素都后移&#x2F;前移，时间复杂度O(n)，时间开销主要来自移动元素。（若数据元素很大，则移动的时间代价很高）<br /><strong>查</strong>：按位查找：O(1)<br />按值查找：O(n) ，若表内元素有序，可在O(㏒₂n)时间内找到。</td>
<td><strong>创</strong>：只需分配一个头节点（也可以不要头节点，只声明一个头指针），之后方便拓展。<br /><strong>销</strong>：依次删除各个节点（free）。<br /><strong>增&#x2F;删</strong>：插入&#x2F;删除元素只需修改指针即可，时间复杂度O(n)，时间开销主要来查找目标元素。（查找元素的时间代价更低）<br /><strong>查</strong>：按位查找：O(n)<br />按值查找：O(n)</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2023/09/17/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>



<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; numsSize; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                <span class="type">int</span>* ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">2</span>);</span><br><span class="line">                ret[<span class="number">0</span>] = i, ret[<span class="number">1</span>] = j;</span><br><span class="line">                *returnSize = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>相交链表</title>
    <url>/2023/09/18/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p>
<p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p>
<p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></a></p>
<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>
<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>
<p><strong>自定义评测：</strong></p>
<p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p>
<ul>
<li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li>
<li><code>listA</code> - 第一个链表</li>
<li><code>listB</code> - 第二个链表</li>
<li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li>
<li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li>
</ul>
<p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Intersected at &#x27;8&#x27;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br><span class="line">— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Intersected at &#x27;2&#x27;</span><br><span class="line">解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class="line">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure>



<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> ListNode *<span class="title function_">getIntersectionNode</span><span class="params">(<span class="keyword">struct</span> ListNode *headA, <span class="keyword">struct</span> ListNode *headB)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">i</span> =</span> headA, *j = headB;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>, len1 = <span class="number">0</span>, len2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len1++;</span><br><span class="line">        i = i-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len2++;</span><br><span class="line">        j = j-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    i = headA, j = headB;</span><br><span class="line">    <span class="keyword">if</span>(len1 &gt; len2)</span><br><span class="line">    &#123;</span><br><span class="line">        len = len1 - len2;</span><br><span class="line">        <span class="keyword">while</span>(len--)</span><br><span class="line">            i = i-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len1 &lt; len2)</span><br><span class="line">    &#123;</span><br><span class="line">        len = len2 - len1;</span><br><span class="line">        <span class="keyword">while</span>(len--)</span><br><span class="line">            j = j-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == j)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i = i-&gt;next;</span><br><span class="line">            j = j-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索插入位置</title>
    <url>/2023/09/17/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">	<span class="type">int</span> low = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> high = numsSize<span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> mid = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">	&#123;</span><br><span class="line">		mid = low + (high-low) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">		&#123;</span><br><span class="line">			high = mid <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(low&gt;high)</span><br><span class="line">                <span class="keyword">return</span> high+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(low&gt;high)</span><br><span class="line">                <span class="keyword">return</span> low;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>交替合并字符串</title>
    <url>/2023/09/20/%E4%BA%A4%E6%9B%BF%E5%90%88%E5%B9%B6%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>给你两个字符串 <code>word1</code> 和 <code>word2</code> 。请你从 <code>word1</code> 开始，通过交替添加字母来合并字符串。如果一个字符串比另一个字符串长，就将多出来的字母追加到合并后字符串的末尾。</p>
<p>返回 <strong>合并后的字符串</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：word1 = &quot;abc&quot;, word2 = &quot;pqr&quot;</span><br><span class="line">输出：&quot;apbqcr&quot;</span><br><span class="line">解释：字符串合并情况如下所示：</span><br><span class="line">word1：  a   b   c</span><br><span class="line">word2：    p   q   r</span><br><span class="line">合并后：  a p b q c r</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：word1 = &quot;ab&quot;, word2 = &quot;pqrs&quot;</span><br><span class="line">输出：&quot;apbqrs&quot;</span><br><span class="line">解释：注意，word2 比 word1 长，&quot;rs&quot; 需要追加到合并后字符串的末尾。</span><br><span class="line">word1：  a   b </span><br><span class="line">word2：    p   q   r   s</span><br><span class="line">合并后：  a p b q   r   s</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：word1 = &quot;abcd&quot;, word2 = &quot;pq&quot;</span><br><span class="line">输出：&quot;apbqcd&quot;</span><br><span class="line">解释：注意，word1 比 word2 长，&quot;cd&quot; 需要追加到合并后字符串的末尾。</span><br><span class="line">word1：  a   b   c   d</span><br><span class="line">word2：    p   q </span><br><span class="line">合并后：  a p b q c   d</span><br></pre></td></tr></table></figure>





<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> * <span class="title function_">mergeAlternately</span><span class="params">(<span class="type">char</span> * word1, <span class="type">char</span> * word2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> len1=<span class="built_in">strlen</span>(word1);</span><br><span class="line">    <span class="type">int</span> len2=<span class="built_in">strlen</span>(word2);</span><br><span class="line">    <span class="type">char</span> *word3=(<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*(len1+len2+<span class="number">1</span>));</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;len1 || i&lt;len2;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;len1)  word3[j++]=word1[i];</span><br><span class="line">        <span class="keyword">if</span>(i&lt;len2)  word3[j++]=word2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    word3[j]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> word3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>找不同</title>
    <url>/2023/09/20/%E6%89%BE%E4%B8%8D%E5%90%8C/</url>
    <content><![CDATA[<p>给定两个字符串 <code>s</code> 和 <code>t</code> ，它们只包含小写字母。</p>
<p>字符串 <code>t</code> 由字符串 <code>s</code> 随机重排，然后在随机位置添加一个字母。</p>
<p>请找出在 <code>t</code> 中被添加的字母。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abcd&quot;, t = &quot;abcde&quot;</span><br><span class="line">输出：&quot;e&quot;</span><br><span class="line">解释：&#x27;e&#x27; 是那个被添加的字母。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;&quot;, t = &quot;y&quot;</span><br><span class="line">输出：&quot;y&quot;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="title function_">findTheDifference</span><span class="params">(<span class="type">char</span> * s, <span class="type">char</span> * t)</span>&#123;</span><br><span class="line">    <span class="type">int</span> as = <span class="number">0</span>, at = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*s)</span><br><span class="line">        as += (*s++);</span><br><span class="line">    <span class="keyword">while</span> (*t)</span><br><span class="line">        at += (*t++);</span><br><span class="line">    <span class="keyword">return</span> at - as;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>在区间范围内统计奇数数目</title>
    <url>/2023/09/19/%E5%9C%A8%E5%8C%BA%E9%97%B4%E8%8C%83%E5%9B%B4%E5%86%85%E7%BB%9F%E8%AE%A1%E5%A5%87%E6%95%B0%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<p>给你两个非负整数 <code>low</code> 和 <code>high</code> 。请你返回 <code>low</code> 和 <code>high</code> 之间（包括二者）奇数的数目。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：low = 3, high = 7</span><br><span class="line">输出：3</span><br><span class="line">解释：3 到 7 之间奇数数字为 [3,5,7] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：low = 8, high = 10</span><br><span class="line">输出：1</span><br><span class="line">解释：8 到 10 之间奇数数字为 [9] 。</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">countOdds</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low%<span class="number">2</span> == <span class="number">0</span> &amp;&amp; high%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (high-low)/<span class="number">2</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(low%<span class="number">2</span> == <span class="number">1</span> || high%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (high-low)/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>爬楼梯</title>
    <url>/2023/09/19/%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶</span><br><span class="line">2. 2 阶</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶 + 1 阶</span><br><span class="line">2. 1 阶 + 2 阶</span><br><span class="line">3. 2 阶 + 1 阶</span><br></pre></td></tr></table></figure>



<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="type">int</span> num[n+<span class="number">1</span>];</span><br><span class="line">    num[<span class="number">0</span>]=<span class="number">1</span>,num[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        num[i]=num[i<span class="number">-1</span>]+num[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>移动零</title>
    <url>/2023/09/17/%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0]</span><br><span class="line">输出: [0]</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;numsSize;i++)   <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)  nums[j++]=nums[i];</span><br><span class="line">    <span class="keyword">for</span>(i=j;i&lt;numsSize;i++) nums[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>找出字符串中第一个匹配项的下标</title>
    <url>/2023/09/21/%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87/</url>
    <content><![CDATA[<p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：&quot;sad&quot; 在下标 0 和 6 处匹配。</span><br><span class="line">第一个匹配项的下标是 0 ，所以返回 0 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：haystack = &quot;leetcode&quot;, needle = &quot;leeto&quot;</span><br><span class="line">输出：-1</span><br><span class="line">解释：&quot;leeto&quot; 没有在 &quot;leetcode&quot; 中出现，所以返回 -1 。</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strStr</span><span class="params">(<span class="type">char</span> * haystack, <span class="type">char</span> * needle)</span>&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(haystack);i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(haystack[i]==needle[j++])&#123;</span><br><span class="line">            num = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="built_in">strlen</span>(needle))&#123;</span><br><span class="line">                <span class="keyword">return</span> (i-j+<span class="number">1</span>);             <span class="comment">//+1是因为j++会比i++先执行</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num)&#123;                           </span><br><span class="line">            i=i-j+<span class="number">1</span>;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        j=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最后一个单词的长度</title>
    <url>/2023/09/21/%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<p>给你一个字符串 <code>s</code>，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 <strong>最后一个</strong> 单词的长度。</p>
<p><strong>单词</strong> 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;Hello World&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：最后一个单词是“World”，长度为5。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;   fly me   to   the moon  &quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：最后一个单词是“moon”，长度为4。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;luffy is still joyboy&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：最后一个单词是长度为6的“joyboy”。</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lengthOfLastWord</span><span class="params">(<span class="type">char</span> * s)</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> str=<span class="built_in">strlen</span>(s)<span class="number">-1</span>;str&gt;=<span class="number">0</span>;str--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[str]!=<span class="number">32</span>)  sum += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[str]==<span class="number">32</span> &amp;&amp; sum!=<span class="number">0</span>)    <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的字母异位词</title>
    <url>/2023/09/22/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    <content><![CDATA[<p>给定两个字符串 <code>*s*</code> 和 <code>*t*</code> ，编写一个函数来判断 <code>*t*</code> 是否是 <code>*s*</code> 的字母异位词。</p>
<p><strong>注意：</strong>若 <code>*s*</code> 和 <code>*t*</code> 中每个字符出现的次数都相同，则称 <code>*s*</code> 和 <code>*t*</code> 互为字母异位词。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isAnagram</span><span class="params">(<span class="type">char</span> * s, <span class="type">char</span> * t)</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> str1=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">int</span> str2=<span class="built_in">strlen</span>(t);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;str1;i++) sum[s[i]-<span class="string">&#x27;a&#x27;</span>]+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;str2;i++) sum[t[i]-<span class="string">&#x27;a&#x27;</span>]-=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) <span class="keyword">if</span>(sum[i] != <span class="number">0</span>)   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>转换成小写字母</title>
    <url>/2023/09/22/%E8%BD%AC%E6%8D%A2%E6%88%90%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<p>给你一个字符串 <code>s</code> ，将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;Hello&quot;</span><br><span class="line">输出：&quot;hello&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;here&quot;</span><br><span class="line">输出：&quot;here&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;LOVELY&quot;</span><br><span class="line">输出：&quot;lovely&quot;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">char</span> * <span class="title function_">toLowerCase</span><span class="params">(<span class="type">char</span> * s)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(s);i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]&gt;<span class="number">64</span> &amp;&amp; s[i]&lt;<span class="number">91</span>)    s[i]+=<span class="number">32</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>加一</title>
    <url>/2023/09/23/%E5%8A%A0%E4%B8%80/</url>
    <content><![CDATA[<p>给定一个由 <strong>整数</strong> 组成的 <strong>非空</strong> 数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储<strong>单个</strong>数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = [1,2,3]</span><br><span class="line">输出：[1,2,4]</span><br><span class="line">解释：输入数组表示数字 123。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = [4,3,2,1]</span><br><span class="line">输出：[4,3,2,2]</span><br><span class="line">解释：输入数组表示数字 4321。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = [0]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">plusOne</span><span class="params">(<span class="type">int</span>* digits, <span class="type">int</span> digitsSize, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = digitsSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        digits[i] = digits[i] + <span class="number">1</span>;<span class="comment">//最后元素+1判断是不是10</span></span><br><span class="line">        <span class="comment">//如果当前元素不为10，直接返回数组</span></span><br><span class="line">        <span class="keyword">if</span>(digits[i] != <span class="number">10</span>)&#123;</span><br><span class="line">            *returnSize = digitsSize;</span><br><span class="line">            <span class="keyword">return</span> digits;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一个元素不为10，后面元素可能为10的情况</span></span><br><span class="line">        <span class="keyword">if</span>(digits[i] == <span class="number">10</span>)</span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//元素全为9开辟新数组</span></span><br><span class="line">    <span class="type">int</span>* ans = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (digitsSize + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>) * (digitsSize + <span class="number">1</span>));<span class="comment">//全部置0</span></span><br><span class="line">    ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    *returnSize = digitsSize + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数组元素积的符号</title>
    <url>/2023/09/23/%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%A7%AF%E7%9A%84%E7%AC%A6%E5%8F%B7/</url>
    <content><![CDATA[<p>已知函数 <code>signFunc(x)</code> 将会根据 <code>x</code> 的正负返回特定值：</p>
<ul>
<li>如果 <code>x</code> 是正数，返回 <code>1</code> 。</li>
<li>如果 <code>x</code> 是负数，返回 <code>-1</code> 。</li>
<li>如果 <code>x</code> 是等于 <code>0</code> ，返回 <code>0</code> 。</li>
</ul>
<p>给你一个整数数组 <code>nums</code> 。令 <code>product</code> 为数组 <code>nums</code> 中所有元素值的乘积。</p>
<p>返回 <code>signFunc(product)</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,-2,-3,-4,3,2,1]</span><br><span class="line">输出：1</span><br><span class="line">解释：数组中所有值的乘积是 144 ，且 signFunc(144) = 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,5,0,2,-3]</span><br><span class="line">输出：0</span><br><span class="line">解释：数组中所有值的乘积是 0 ，且 signFunc(0) = 0</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,1,-1,1,-1]</span><br><span class="line">输出：-1</span><br><span class="line">解释：数组中所有值的乘积是 -1 ，且 signFunc(-1) = -1</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">signFunc</span><span class="params">(<span class="type">int</span> product)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(product&gt;<span class="number">0</span>)   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(product&lt;<span class="number">0</span>)   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">arraySign</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> product=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numsSize;i++) product *= signFunc(nums[i]);</span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>棒球比赛</title>
    <url>/2023/09/27/%E6%A3%92%E7%90%83%E6%AF%94%E8%B5%9B/</url>
    <content><![CDATA[<p>你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。</p>
<p>比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 <code>ops</code>，其中 <code>ops[i]</code> 是你需要记录的第 <code>i</code> 项操作，<code>ops</code> 遵循下述规则：</p>
<ol>
<li>整数 <code>x</code> - 表示本回合新获得分数 <code>x</code></li>
<li><code>&quot;+&quot;</code> - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。</li>
<li><code>&quot;D&quot;</code> - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。</li>
<li><code>&quot;C&quot;</code> - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。</li>
</ol>
<p>请你返回记录中所有得分的总和。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：ops = [&quot;5&quot;,&quot;2&quot;,&quot;C&quot;,&quot;D&quot;,&quot;+&quot;]</span><br><span class="line">输出：30</span><br><span class="line">解释：</span><br><span class="line">&quot;5&quot; - 记录加 5 ，记录现在是 [5]</span><br><span class="line">&quot;2&quot; - 记录加 2 ，记录现在是 [5, 2]</span><br><span class="line">&quot;C&quot; - 使前一次得分的记录无效并将其移除，记录现在是 [5].</span><br><span class="line">&quot;D&quot; - 记录加 2 * 5 = 10 ，记录现在是 [5, 10].</span><br><span class="line">&quot;+&quot; - 记录加 5 + 10 = 15 ，记录现在是 [5, 10, 15].</span><br><span class="line">所有得分的总和 5 + 10 + 15 = 30</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：ops = [&quot;5&quot;,&quot;-2&quot;,&quot;4&quot;,&quot;C&quot;,&quot;D&quot;,&quot;9&quot;,&quot;+&quot;,&quot;+&quot;]</span><br><span class="line">输出：27</span><br><span class="line">解释：</span><br><span class="line">&quot;5&quot; - 记录加 5 ，记录现在是 [5]</span><br><span class="line">&quot;-2&quot; - 记录加 -2 ，记录现在是 [5, -2]</span><br><span class="line">&quot;4&quot; - 记录加 4 ，记录现在是 [5, -2, 4]</span><br><span class="line">&quot;C&quot; - 使前一次得分的记录无效并将其移除，记录现在是 [5, -2]</span><br><span class="line">&quot;D&quot; - 记录加 2 * -2 = -4 ，记录现在是 [5, -2, -4]</span><br><span class="line">&quot;9&quot; - 记录加 9 ，记录现在是 [5, -2, -4, 9]</span><br><span class="line">&quot;+&quot; - 记录加 -4 + 9 = 5 ，记录现在是 [5, -2, -4, 9, 5]</span><br><span class="line">&quot;+&quot; - 记录加 9 + 5 = 14 ，记录现在是 [5, -2, -4, 9, 5, 14]</span><br><span class="line">所有得分的总和 5 + -2 + -4 + 9 + 5 + 14 = 27</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：ops = [&quot;1&quot;]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">calPoints</span><span class="params">(<span class="type">char</span> ** operations, <span class="type">int</span> operationsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[operationsSize];</span><br><span class="line">    <span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;operationsSize;i++)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(operations[i][<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span> :</span><br><span class="line">            b--; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span> :</span><br><span class="line">            a[b]=a[b<span class="number">-1</span>]*<span class="number">2</span>; b++; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span> :</span><br><span class="line">            a[b]=a[b<span class="number">-1</span>]+a[b<span class="number">-2</span>]; b++; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span> :</span><br><span class="line">            a[b]=atoi(operations[i]); b++; <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    b--;</span><br><span class="line">    <span class="keyword">while</span>(b&gt;=<span class="number">0</span>) sum+=a[b--];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>机器人能否返回原点</title>
    <url>/2023/09/27/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%83%BD%E5%90%A6%E8%BF%94%E5%9B%9E%E5%8E%9F%E7%82%B9/</url>
    <content><![CDATA[<p>在二维平面上，有一个机器人从原点 <code>(0, 0)</code> 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 <strong><code>(0, 0)</code> 处结束</strong>。</p>
<p>移动顺序由字符串 <code>moves</code> 表示。字符 <code>move[i]</code> 表示其第 <code>i</code> 次移动。机器人的有效动作有 <code>R</code>（右），<code>L</code>（左），<code>U</code>（上）和 <code>D</code>（下）。</p>
<p>如果机器人在完成所有动作后返回原点，则返回 <code>true</code>。否则，返回 <code>false</code>。</p>
<p><strong>注意：</strong>机器人“面朝”的方向无关紧要。 <code>“R”</code> 将始终使机器人向右移动一次，<code>“L”</code> 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: moves = &quot;UD&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: moves = &quot;LL&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">judgeCircle</span><span class="params">(<span class="type">char</span> * moves)</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(moves);i++)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(moves[i])&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>:a++;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:a--;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;U&#x27;</span>:b++;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:b--;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span> &amp;&amp; b==<span class="number">0</span>)    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>去掉最低工资和最高工资后的工资平均值</title>
    <url>/2023/09/28/%E5%8E%BB%E6%8E%89%E6%9C%80%E4%BD%8E%E5%B7%A5%E8%B5%84%E5%92%8C%E6%9C%80%E9%AB%98%E5%B7%A5%E8%B5%84%E5%90%8E%E7%9A%84%E5%B7%A5%E8%B5%84%E5%B9%B3%E5%9D%87%E5%80%BC/</url>
    <content><![CDATA[<p>给你一个整数数组 <code>salary</code> ，数组里每个数都是 <strong>唯一</strong> 的，其中 <code>salary[i]</code> 是第 <code>i</code> 个员工的工资。</p>
<p>请你返回去掉最低工资和最高工资以后，剩下员工工资的平均值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：salary = [4000,3000,1000,2000]</span><br><span class="line">输出：2500.00000</span><br><span class="line">解释：最低工资和最高工资分别是 1000 和 4000 。</span><br><span class="line">去掉最低工资和最高工资以后的平均工资是 (2000+3000)/2= 2500</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：salary = [1000,2000,3000]</span><br><span class="line">输出：2000.00000</span><br><span class="line">解释：最低工资和最高工资分别是 1000 和 3000 。</span><br><span class="line">去掉最低工资和最高工资以后的平均工资是 (2000)/1= 2000</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：salary = [6000,5000,4000,3000,2000,1000]</span><br><span class="line">输出：3500.00000</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：salary = [8000,9000,2000,3000,6000,1000]</span><br><span class="line">输出：4750.00000</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">average</span><span class="params">(<span class="type">int</span>* salary, <span class="type">int</span> salarySize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> min=salary[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> max=salary[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;salarySize;i++)&#123;</span><br><span class="line">        sum += salary[i];</span><br><span class="line">        <span class="keyword">if</span>(salary[i]&lt;min)   min=salary[i];</span><br><span class="line">        <span class="keyword">if</span>(salary[i]&gt;max)   max=salary[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)(sum-min-max)/(salarySize<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>找出井字棋的获胜者</title>
    <url>/2023/09/28/%E6%89%BE%E5%87%BA%E4%BA%95%E5%AD%97%E6%A3%8B%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85/</url>
    <content><![CDATA[<p><em>A</em> 和 <em>B</em> 在一个 <em>3</em> x <em>3</em> 的网格上玩井字棋。</p>
<p>井字棋游戏的规则如下：</p>
<ul>
<li>玩家轮流将棋子放在空方格 (“ “) 上。</li>
<li>第一个玩家 A 总是用 “X” 作为棋子，而第二个玩家 B 总是用 “O” 作为棋子。</li>
<li>“X” 和 “O” 只能放在空方格中，而不能放在已经被占用的方格上。</li>
<li>只要有 3 个相同的（非空）棋子排成一条直线（行、列、对角线）时，游戏结束。</li>
<li>如果所有方块都放满棋子（不为空），游戏也会结束。</li>
<li>游戏结束后，棋子无法再进行任何移动。</li>
</ul>
<p>给你一个数组 <code>moves</code>，其中每个元素是大小为 <code>2</code> 的另一个数组（元素分别对应网格的行和列），它按照 <em>A</em> 和 <em>B</em> 的行动顺序（先 <em>A</em> 后 <em>B</em>）记录了两人各自的棋子位置。</p>
<p>如果游戏存在获胜者（<em>A</em> 或 <em>B</em>），就返回该游戏的获胜者；如果游戏以平局结束，则返回 “Draw”；如果仍会有行动（游戏未结束），则返回 “Pending”。</p>
<p>你可以假设 <code>moves</code> 都 <strong>有效</strong>（遵循井字棋规则），网格最初是空的，<em>A</em> 将先行动。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]</span><br><span class="line">输出：&quot;A&quot;</span><br><span class="line">解释：&quot;A&quot; 获胜，他总是先走。</span><br><span class="line">&quot;X  &quot;    &quot;X  &quot;    &quot;X  &quot;    &quot;X  &quot;    &quot;X  &quot;</span><br><span class="line">&quot;   &quot; -&gt; &quot;   &quot; -&gt; &quot; X &quot; -&gt; &quot; X &quot; -&gt; &quot; X &quot;</span><br><span class="line">&quot;   &quot;    &quot;O  &quot;    &quot;O  &quot;    &quot;OO &quot;    &quot;OOX&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]</span><br><span class="line">输出：&quot;B&quot;</span><br><span class="line">解释：&quot;B&quot; 获胜。</span><br><span class="line">&quot;X  &quot;    &quot;X  &quot;    &quot;XX &quot;    &quot;XXO&quot;    &quot;XXO&quot;    &quot;XXO&quot;</span><br><span class="line">&quot;   &quot; -&gt; &quot; O &quot; -&gt; &quot; O &quot; -&gt; &quot; O &quot; -&gt; &quot;XO &quot; -&gt; &quot;XO &quot; </span><br><span class="line">&quot;   &quot;    &quot;   &quot;    &quot;   &quot;    &quot;   &quot;    &quot;   &quot;    &quot;O  &quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]</span><br><span class="line">输出：&quot;Draw&quot;</span><br><span class="line">输出：由于没有办法再行动，游戏以平局结束。</span><br><span class="line">&quot;XXO&quot;</span><br><span class="line">&quot;OOX&quot;</span><br><span class="line">&quot;XOX&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：moves = [[0,0],[1,1]]</span><br><span class="line">输出：&quot;Pending&quot;</span><br><span class="line">解释：游戏还没有结束。</span><br><span class="line">&quot;X  &quot;</span><br><span class="line">&quot; O &quot;</span><br><span class="line">&quot;   &quot;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">tictactoe</span><span class="params">(<span class="type">int</span>** moves, <span class="type">int</span> movesSize, <span class="type">int</span>* movesColSize)</span>&#123;</span><br><span class="line">    <span class="comment">// 将 moves 填入虚拟棋盘， a 为 1 ， b 为 -1</span></span><br><span class="line">    <span class="type">int</span> s[<span class="number">3</span>][<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; movesSize; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x = moves[i][<span class="number">0</span>], y = moves[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (i &amp; <span class="number">1</span>) s[x][y]--;</span><br><span class="line">        <span class="keyword">else</span> s[x][y]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对角线判断</span></span><br><span class="line">    <span class="type">int</span> sumD1 = s[<span class="number">0</span>][<span class="number">0</span>] + s[<span class="number">1</span>][<span class="number">1</span>] + s[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> sumD2 = s[<span class="number">0</span>][<span class="number">2</span>] + s[<span class="number">1</span>][<span class="number">1</span>] + s[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (sumD1 ==  <span class="number">3</span> || sumD2 ==  <span class="number">3</span>) <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (sumD1 == <span class="number">-3</span> || sumD2 == <span class="number">-3</span>) <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>;</span><br><span class="line">    <span class="comment">// 横向、纵向判断</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> sumR = s[i][<span class="number">0</span>] + s[i][<span class="number">1</span>] + s[i][<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> sumC = s[<span class="number">0</span>][i] + s[<span class="number">1</span>][i] + s[<span class="number">2</span>][i];</span><br><span class="line">        <span class="keyword">if</span> (sumR ==  <span class="number">3</span> || sumC ==  <span class="number">3</span>) <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (sumR == <span class="number">-3</span> || sumC == <span class="number">-3</span>) <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 无胜者情况</span></span><br><span class="line">    <span class="keyword">return</span> movesSize &lt; <span class="number">9</span> ? <span class="string">&quot;Pending&quot;</span> : <span class="string">&quot;Draw&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>判断能否形成等差数列</title>
    <url>/2023/09/29/%E5%88%A4%E6%96%AD%E8%83%BD%E5%90%A6%E5%BD%A2%E6%88%90%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<p>给你一个数字数组 <code>arr</code> 。</p>
<p>如果一个数列中，任意相邻两项的差总等于同一个常数，那么这个数列就称为 <strong>等差数列</strong> 。</p>
<p>如果可以重新排列数组形成等差数列，请返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [3,5,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：对数组重新排序得到 [1,3,5] 或者 [5,3,1] ，任意相邻两项的差分别为 2 或 -2 ，可以形成等差数列。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [1,2,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无法通过重新排序得到等差数列。</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">canMakeArithmeticProgression</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> arrSize)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arrSize<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;arrSize-i<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                arr[j] = arr[j] + arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j] - arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j] = arr[j] - arr[j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num =arr[<span class="number">0</span>]-arr[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;arrSize;i++)&#123;</span><br><span class="line">        temp -= num;</span><br><span class="line">        <span class="keyword">if</span>(temp != arr[i])  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>柠檬水找零</title>
    <url>/2023/09/29/%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/</url>
    <content><![CDATA[<p>在柠檬水摊上，每一杯柠檬水的售价为 <code>5</code> 美元。顾客排队购买你的产品，（按账单 <code>bills</code> 支付的顺序）一次购买一杯。</p>
<p>每位顾客只买一杯柠檬水，然后向你付 <code>5</code> 美元、<code>10</code> 美元或 <code>20</code> 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 <code>5</code> 美元。</p>
<p>注意，一开始你手头没有任何零钱。</p>
<p>给你一个整数数组 <code>bills</code> ，其中 <code>bills[i]</code> 是第 <code>i</code> 位顾客付的账。如果你能给每位顾客正确找零，返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：bills = [5,5,5,10,20]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。</span><br><span class="line">第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。</span><br><span class="line">第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。</span><br><span class="line">由于所有客户都得到了正确的找零，所以我们输出 true。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：bills = [5,5,10,10,20]</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。</span><br><span class="line">对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。</span><br><span class="line">对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。</span><br><span class="line">由于不是每位顾客都得到了正确的找零，所以答案是 false。</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">lemonadeChange</span><span class="params">(<span class="type">int</span>* bills, <span class="type">int</span> billsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> a5=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a10=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;billsSize;i++)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(bills[i])&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>: a5++;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>: a5--,a10++;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">20</span>: (a10&gt;<span class="number">0</span>) ? (a10--,a5--) : (a5-=<span class="number">3</span>);<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a10&lt;<span class="number">0</span> || a5&lt;<span class="number">0</span>)   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>单调数列</title>
    <url>/2023/09/30/%E5%8D%95%E8%B0%83%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<p>如果数组是单调递增或单调递减的，那么它是 <strong>单调</strong> <em>的</em>。</p>
<p>如果对于所有 <code>i &lt;= j</code>，<code>nums[i] &lt;= nums[j]</code>，那么数组 <code>nums</code> 是单调递增的。 如果对于所有 <code>i &lt;= j</code>，<code>nums[i]&gt; = nums[j]</code>，那么数组 <code>nums</code> 是单调递减的。</p>
<p>当给定的数组 <code>nums</code> 是单调数组时返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,2,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [6,5,4,4]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isMonotonic</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numsSize<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;=nums[i+<span class="number">1</span>])   a++;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&lt;=nums[i+<span class="number">1</span>])   b++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a==numsSize || b==numsSize) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>罗马数字转整数</title>
    <url>/2023/10/01/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>

<p>例如， 罗马数字 <code>2</code> 写做 <code>II</code> ，即为两个并列的 1 。<code>12</code> 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 <code>27</code> 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个罗马数字，将其转换成整数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;IX&quot;</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure>

<p><strong>示例 5:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">romanToInt</span><span class="params">(<span class="type">char</span> * s)</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(s);i++)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(s[i])&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:<span class="keyword">if</span>(s[i+<span class="number">1</span>] == <span class="string">&#x27;V&#x27;</span>)  sum+=<span class="number">4</span>,i++;</span><br><span class="line">                     <span class="keyword">else</span> <span class="keyword">if</span>(s[i+<span class="number">1</span>] == <span class="string">&#x27;X&#x27;</span>) sum+=<span class="number">9</span>,i++;</span><br><span class="line">                     <span class="keyword">else</span>   sum+=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>:sum+=<span class="number">5</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:<span class="keyword">if</span>(s[i+<span class="number">1</span>] == <span class="string">&#x27;L&#x27;</span>)  sum+=<span class="number">40</span>,i++;</span><br><span class="line">                     <span class="keyword">else</span> <span class="keyword">if</span>(s[i+<span class="number">1</span>] == <span class="string">&#x27;C&#x27;</span>) sum+=<span class="number">90</span>,i++;</span><br><span class="line">                     <span class="keyword">else</span>   sum+=<span class="number">10</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:sum+=<span class="number">50</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:<span class="keyword">if</span>(s[i+<span class="number">1</span>] == <span class="string">&#x27;D&#x27;</span>)  sum+=<span class="number">400</span>,i++;</span><br><span class="line">                     <span class="keyword">else</span> <span class="keyword">if</span>(s[i+<span class="number">1</span>] == <span class="string">&#x27;M&#x27;</span>) sum+=<span class="number">900</span>,i++;</span><br><span class="line">                     <span class="keyword">else</span>   sum+=<span class="number">100</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:sum+=<span class="number">500</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:sum+=<span class="number">1000</span>;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>重复的子字符串</title>
    <url>/2023/10/01/%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>给定一个非空的字符串 <code>s</code> ，检查是否可以通过由它的一个子串重复多次构成。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;abab&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 可由子串 &quot;ab&quot; 重复两次构成。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;aba&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;abcabcabcabc&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 可由子串 &quot;abc&quot; 重复四次构成。 (或子串 &quot;abcabc&quot; 重复两次构成。)</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(<span class="type">char</span> * s)</span>&#123;</span><br><span class="line">    <span class="type">int</span> str=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=str/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str%i==<span class="number">0</span>)&#123;</span><br><span class="line">            flag=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;str;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j-i] != s[j])&#123;</span><br><span class="line">                    flag=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="literal">true</span>)  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>困于环中的机器人</title>
    <url>/2023/10/02/%E5%9B%B0%E4%BA%8E%E7%8E%AF%E4%B8%AD%E7%9A%84%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
    <content><![CDATA[<p>在无限的平面上，机器人最初位于 <code>(0, 0)</code> 处，面朝北方。注意:</p>
<ul>
<li><strong>北方向</strong> 是y轴的正方向。</li>
<li><strong>南方向</strong> 是y轴的负方向。</li>
<li><strong>东方向</strong> 是x轴的正方向。</li>
<li><strong>西方向</strong> 是x轴的负方向。</li>
</ul>
<p>机器人可以接受下列三条指令之一：</p>
<ul>
<li><code>&quot;G&quot;</code>：直走 1 个单位</li>
<li><code>&quot;L&quot;</code>：左转 90 度</li>
<li><code>&quot;R&quot;</code>：右转 90 度</li>
</ul>
<p>机器人按顺序执行指令 <code>instructions</code>，并一直重复它们。</p>
<p>只有在平面中存在环使得机器人永远无法离开时，返回 <code>true</code>。否则，返回 <code>false</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：instructions = &quot;GGLLGG&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：机器人最初在(0,0)处，面向北方。</span><br><span class="line">“G”:移动一步。位置:(0,1)方向:北。</span><br><span class="line">“G”:移动一步。位置:(0,2).方向:北。</span><br><span class="line">“L”:逆时针旋转90度。位置:(0,2).方向:西。</span><br><span class="line">“L”:逆时针旋转90度。位置:(0,2)方向:南。</span><br><span class="line">“G”:移动一步。位置:(0,1)方向:南。</span><br><span class="line">“G”:移动一步。位置:(0,0)方向:南。</span><br><span class="line">重复指令，机器人进入循环:(0,0)——&gt;(0,1)——&gt;(0,2)——&gt;(0,1)——&gt;(0,0)。</span><br><span class="line">在此基础上，我们返回true。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：instructions = &quot;GG&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：机器人最初在(0,0)处，面向北方。</span><br><span class="line">“G”:移动一步。位置:(0,1)方向:北。</span><br><span class="line">“G”:移动一步。位置:(0,2).方向:北。</span><br><span class="line">重复这些指示，继续朝北前进，不会进入循环。</span><br><span class="line">在此基础上，返回false。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：instructions = &quot;GL&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：机器人最初在(0,0)处，面向北方。</span><br><span class="line">“G”:移动一步。位置:(0,1)方向:北。</span><br><span class="line">“L”:逆时针旋转90度。位置:(0,1).方向:西。</span><br><span class="line">“G”:移动一步。位置:(- 1,1)方向:西。</span><br><span class="line">“L”:逆时针旋转90度。位置:(- 1,1)方向:南。</span><br><span class="line">“G”:移动一步。位置:(- 1,0)方向:南。</span><br><span class="line">“L”:逆时针旋转90度。位置:(- 1,0)方向:东方。</span><br><span class="line">“G”:移动一步。位置:(0,0)方向:东方。</span><br><span class="line">“L”:逆时针旋转90度。位置:(0,0)方向:北。</span><br><span class="line">重复指令，机器人进入循环:(0,0)——&gt;(0,1)——&gt;(- 1,1)——&gt;(- 1,0)——&gt;(0,0)。</span><br><span class="line">在此基础上，我们返回true。</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isRobotBounded</span><span class="params">(<span class="type">char</span> * instructions)</span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> direction=<span class="number">1</span>;    <span class="comment">//北1 东2 南3 西4</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(instructions);i++)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(instructions[i])&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>:<span class="keyword">switch</span>(direction)&#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">1</span>:y++;<span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">2</span>:x++;<span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">3</span>:y--;<span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">4</span>:x--;<span class="keyword">break</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:<span class="keyword">if</span>(direction==<span class="number">1</span>)   direction=<span class="number">4</span>;</span><br><span class="line">                     <span class="keyword">else</span>   direction-=<span class="number">1</span>;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>:<span class="keyword">if</span>(direction==<span class="number">4</span>)   direction=<span class="number">1</span>;</span><br><span class="line">                     <span class="keyword">else</span>   direction+=<span class="number">1</span>;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回到坐标原点或者最后方向不朝向北说明会进入环</span></span><br><span class="line">    <span class="keyword">if</span>((x==<span class="number">0</span> &amp;&amp; y==<span class="number">0</span>) || (direction!=<span class="number">1</span>))    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最富有客户的资产总量</title>
    <url>/2023/10/02/%E6%9C%80%E5%AF%8C%E6%9C%89%E5%AE%A2%E6%88%B7%E7%9A%84%E8%B5%84%E4%BA%A7%E6%80%BB%E9%87%8F/</url>
    <content><![CDATA[<p>给你一个 <code>m x n</code> 的整数网格 <code>accounts</code> ，其中 <code>accounts[i][j]</code> 是第 <code>i</code> 位客户在第 <code>j</code> 家银行托管的资产数量。返回最富有客户所拥有的 <strong>资产总量</strong> 。</p>
<p>客户的 <strong>资产总量</strong> 就是他们在各家银行托管的资产数量之和。最富有客户就是 <strong>资产总量</strong> 最大的客户。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：accounts = [[1,2,3],[3,2,1]]</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">第 1 位客户的资产总量 = 1 + 2 + 3 = 6</span><br><span class="line">第 2 位客户的资产总量 = 3 + 2 + 1 = 6</span><br><span class="line">两位客户都是最富有的，资产总量都是 6 ，所以返回 6 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：accounts = [[1,5],[7,3],[3,5]]</span><br><span class="line">输出：10</span><br><span class="line">解释：</span><br><span class="line">第 1 位客户的资产总量 = 6</span><br><span class="line">第 2 位客户的资产总量 = 10 </span><br><span class="line">第 3 位客户的资产总量 = 8</span><br><span class="line">第 2 位客户是最富有的，资产总量是 10</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：accounts = [[2,8,7],[7,1,3],[1,9,5]]</span><br><span class="line">输出：17</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maximumWealth</span><span class="params">(<span class="type">int</span>** accounts, <span class="type">int</span> accountsSize, <span class="type">int</span>* accountsColSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> max=accounts[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;accountsSize;i++)&#123;</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;*accountsColSize;j++)&#123;</span><br><span class="line">            sum+=accounts[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        accountsColSize++;</span><br><span class="line">        <span class="keyword">if</span>(max&lt;sum) max=sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵对角线元素的和</title>
    <url>/2023/10/03/%E7%9F%A9%E9%98%B5%E5%AF%B9%E8%A7%92%E7%BA%BF%E5%85%83%E7%B4%A0%E7%9A%84%E5%92%8C/</url>
    <content><![CDATA[<p>给你一个正方形矩阵 <code>mat</code>，请你返回矩阵对角线元素的和。</p>
<p>请你返回在矩阵主对角线上的元素和副对角线上且不在主对角线上元素的和。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/08/14/sample_1911.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：mat = [[1,2,3],</span><br><span class="line">            [4,5,6],</span><br><span class="line">            [7,8,9]]</span><br><span class="line">输出：25</span><br><span class="line">解释：对角线的和为：1 + 5 + 9 + 3 + 7 = 25</span><br><span class="line">请注意，元素 mat[1][1] = 5 只会被计算一次。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：mat = [[1,1,1,1],</span><br><span class="line">            [1,1,1,1],</span><br><span class="line">            [1,1,1,1],</span><br><span class="line">            [1,1,1,1]]</span><br><span class="line">输出：8</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：mat = [[5]]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">diagonalSum</span><span class="params">(<span class="type">int</span>** mat, <span class="type">int</span> matSize, <span class="type">int</span>* matColSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;matSize;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;*matColSize;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j) sum+=mat[i][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i+j == matSize<span class="number">-1</span>) sum+=mat[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>缀点成线</title>
    <url>/2023/10/03/%E7%BC%80%E7%82%B9%E6%88%90%E7%BA%BF/</url>
    <content><![CDATA[<p>给定一个数组 <code>coordinates</code> ，其中 <code>coordinates[i] = [x, y]</code> ， <code>[x, y]</code> 表示横坐标为 <code>x</code>、纵坐标为 <code>y</code> 的点。请你来判断，这些点是否在该坐标系中属于同一条直线上。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/untitled-diagram-2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/untitled-diagram-1.jpg" alt="img"></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">checkStraightLine</span><span class="params">(<span class="type">int</span>** coordinates, <span class="type">int</span> coordinatesSize, <span class="type">int</span>* coordinatesColSize)</span>&#123;</span><br><span class="line"><span class="comment">//判断前后两个点是否在一个直线上,就判断相邻两个点的斜率是否相等.</span></span><br><span class="line"><span class="comment">//先对前两个点进行操作</span></span><br><span class="line">    <span class="type">int</span> x1 = coordinates[<span class="number">1</span>][<span class="number">0</span>] - coordinates[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> y1 = coordinates[<span class="number">1</span>][<span class="number">1</span>] - coordinates[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"><span class="comment">//对后面的数组开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; coordinatesSize; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x2 = coordinates[i][<span class="number">0</span>] - coordinates[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> y2 = coordinates[i][<span class="number">1</span>] - coordinates[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (x1 * y2 != x2 * y1) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>回文数</title>
    <url>/2023/10/05/%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    <content><![CDATA[<p>给你一个整数 <code>x</code> ，如果 <code>x</code> 是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<ul>
<li>例如，<code>121</code> 是回文，而 <code>123</code> 不是。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 121</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = -121</span><br><span class="line">输出：false</span><br><span class="line">解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 10</span><br><span class="line">输出：false</span><br><span class="line">解释：从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> y=x;</span><br><span class="line">    <span class="type">int</span> a,i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        y/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    y=x;</span><br><span class="line">    i-=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        a=y%<span class="number">10</span>;</span><br><span class="line">        sum+=a*<span class="built_in">pow</span>(<span class="number">10</span>,i);</span><br><span class="line">        i--;</span><br><span class="line">        y/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==sum)  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>x 的平方根</title>
    <url>/2023/10/05/x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
    <content><![CDATA[<p>给你一个非负整数 <code>x</code> ，计算并返回 <code>x</code> 的 <strong>算术平方根</strong> 。</p>
<p>由于返回类型是整数，结果只保留 <strong>整数部分</strong> ，小数部分将被 <strong>舍去 。</strong></p>
<p><strong>注意：</strong>不允许使用任何内置指数函数和算符，例如 <code>pow(x, 0.5)</code> 或者 <code>x ** 0.5</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 4</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 8</span><br><span class="line">输出：2</span><br><span class="line">解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>;      <span class="comment">//用int类型可能会溢出</span></span><br><span class="line">    <span class="keyword">while</span>(i*i&lt;=x)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>相同的树</title>
    <url>/2023/10/06/%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</url>
    <content><![CDATA[<p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：p = [1,2,3], q = [1,2,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：p = [1,2], q = [1,null,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：p = [1,2,1], q = [1,1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isSameTree</span><span class="params">(<span class="keyword">struct</span> TreeNode* p, <span class="keyword">struct</span> TreeNode* q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span> || q==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span> &amp;&amp; q==<span class="literal">NULL</span>)  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;val ==  q-&gt;val)   <span class="keyword">return</span> isSameTree(p-&gt;left,q-&gt;left) &amp;&amp; isSameTree(p-&gt;right,q-&gt;right);</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>路径总和</title>
    <url>/2023/10/06/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</span><br><span class="line">输出：true</span><br><span class="line">解释：等于目标和的根节点到叶节点路径如上图所示。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,3], targetSum = 5</span><br><span class="line">输出：false</span><br><span class="line">解释：树中存在两条根节点到叶子节点的路径：</span><br><span class="line">(1 --&gt; 2): 和为 3</span><br><span class="line">(1 --&gt; 3): 和为 4</span><br><span class="line">不存在 sum = 5 的根节点到叶子节点的路径。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [], targetSum = 0</span><br><span class="line">输出：false</span><br><span class="line">解释：由于树是空的，所以不存在根节点到叶子节点的路径。</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">hasPathSum</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> targetSum)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(targetSum == root-&gt;val)  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root-&gt;left,targetSum-root-&gt;val) || </span><br><span class="line">           hasPathSum(root-&gt;right,targetSum-root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>丑数</title>
    <url>/2023/10/07/%E4%B8%91%E6%95%B0/</url>
    <content><![CDATA[<p><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和 <code>5</code> 的正整数。</p>
<p>给你一个整数 <code>n</code> ，请你判断 <code>n</code> 是否为 <strong>丑数</strong> 。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 6</span><br><span class="line">输出：true</span><br><span class="line">解释：6 = 2 × 3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：1 没有质因数，因此它的全部质因数是 &#123;2, 3, 5&#125; 的空集。习惯上将其视作第一个丑数。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 14</span><br><span class="line">输出：false</span><br><span class="line">解释：14 不是丑数，因为它包含了另外一个质因数 7 。</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isUgly</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)  n/=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n%<span class="number">3</span>==<span class="number">0</span>) n/=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n%<span class="number">5</span>==<span class="number">0</span>) n/=<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n==<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>多数元素</title>
    <url>/2023/10/07/%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,3]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,2,1,1,1,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,num=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;numsSize;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == nums[i])   j++;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            j&gt;<span class="number">0</span>?(j--):(num=nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>报数</title>
    <url>/2023/10/09/%E6%8A%A5%E6%95%B0/</url>
    <content><![CDATA[<p>实现一个十进制数字报数程序，请按照数字从小到大的顺序返回一个证书数列，该数列从数字 <code>1</code> 开始，到最大的正整数 <code>cnt</code> 位数字结束。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：cnt = 2</span><br><span class="line">输出：[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99]</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">countNumbers</span><span class="params">(<span class="type">int</span> cnt, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(cnt &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        num *= <span class="number">10</span>;</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> *ans = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (num - <span class="number">1</span>));  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;num;i++)&#123;</span><br><span class="line">        ans[i<span class="number">-1</span>]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize=num<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="built_in">free</span>(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>连续数列</title>
    <url>/2023/10/09/%E8%BF%9E%E7%BB%AD%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<p>给定一个整数数组，找出总和最大的连续数列，并返回总和。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入： [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出： 6</span><br><span class="line">解释： 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>



<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> max=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numsSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp+=nums[i];</span><br><span class="line">        <span class="keyword">if</span>(temp&gt;max)    max=temp;</span><br><span class="line">        <span class="keyword">if</span>(temp&lt;<span class="number">0</span>)  temp=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快乐数</title>
    <url>/2023/10/08/%E5%BF%AB%E4%B9%90%E6%95%B0/</url>
    <content><![CDATA[<p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p>
<p><strong>「快乐数」</strong> 定义为：</p>
<ul>
<li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li>
<li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li>
<li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li>
</ul>
<p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 19</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">12 + 92 = 82</span><br><span class="line">82 + 22 = 68</span><br><span class="line">62 + 82 = 100</span><br><span class="line">12 + 02 + 02 = 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> num,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">810</span>]=&#123;<span class="number">0</span>&#125;;       <span class="comment">//2^31共10个数每个数最大为9即10*9^2</span></span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            num=n%<span class="number">10</span>;</span><br><span class="line">            sum+=num*num;</span><br><span class="line">            n/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[sum]==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span>    arr[sum]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sum == <span class="number">1</span>)   <span class="keyword">break</span>;</span><br><span class="line">        n=sum;</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>翻转图像</title>
    <url>/2023/10/10/%E7%BF%BB%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<p>给定一个 <code>n x n</code> 的二进制矩阵 <code>image</code> ，先 <strong>水平</strong> 翻转图像，然后 <strong>反转</strong> 图像并返回 <em>结果</em> 。</p>
<p><strong>水平</strong>翻转图片就是将图片的每一行都进行翻转，即逆序。</p>
<ul>
<li>例如，水平翻转 <code>[1,1,0]</code> 的结果是 <code>[0,1,1]</code>。</li>
</ul>
<p><strong>反转</strong>图片的意思是图片中的 <code>0</code> 全部被 <code>1</code> 替换， <code>1</code> 全部被 <code>0</code> 替换。</p>
<ul>
<li>例如，反转 <code>[0,1,1]</code> 的结果是 <code>[1,0,0]</code>。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：image = [[1,1,0],[1,0,1],[0,0,0]]</span><br><span class="line">输出：[[1,0,0],[0,1,0],[1,1,1]]</span><br><span class="line">解释：首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；</span><br><span class="line">     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]</span><br><span class="line">输出：[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br><span class="line">解释：首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；</span><br><span class="line">     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an array of arrays of size *returnSize.</span></span><br><span class="line"><span class="comment"> * The sizes of the arrays are returned as *returnColumnSizes array.</span></span><br><span class="line"><span class="comment"> * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>** <span class="title function_">flipAndInvertImage</span><span class="params">(<span class="type">int</span>** image, <span class="type">int</span> imageSize, <span class="type">int</span>* imageColSize, <span class="type">int</span>* returnSize, <span class="type">int</span>** returnColumnSizes)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;imageSize;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;imageColSize[i]/<span class="number">2</span>;j++)&#123;</span><br><span class="line">            image[i][j]=image[i][j]^image[i][imageSize<span class="number">-1</span>-j];</span><br><span class="line">            image[i][imageSize<span class="number">-1</span>-j]=image[i][j]^image[i][imageSize<span class="number">-1</span>-j];</span><br><span class="line">            image[i][j]=image[i][j]^image[i][imageSize<span class="number">-1</span>-j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;imageColSize[i];j++)&#123;</span><br><span class="line">            image[i][j] ^= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize=imageSize;</span><br><span class="line">    *returnColumnSizes=imageColSize;</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>只出现一次的数字</title>
    <url>/2023/10/22/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>给你一个 <strong>非空</strong> 整数数组 <code>nums</code> ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p>
<p><strong>示例 1 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,2,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,1,2,1,2]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>

<p><strong>示例 3 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numsSize;i++)&#123;</span><br><span class="line">        res ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>老人的数目</title>
    <url>/2023/10/23/%E8%80%81%E4%BA%BA%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>details</code> 。<code>details</code> 中每个元素都是一位乘客的信息，信息用长度为 <code>15</code> 的字符串表示，表示方式如下：</p>
<ul>
<li>前十个字符是乘客的手机号码。</li>
<li>接下来的一个字符是乘客的性别。</li>
<li>接下来两个字符是乘客的年龄。</li>
<li>最后两个字符是乘客的座位号。</li>
</ul>
<p>请你返回乘客中年龄 <strong>严格大于 60 岁</strong> 的人数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：details = [&quot;7868190130M7522&quot;,&quot;5303914400F9211&quot;,&quot;9273338290F4010&quot;]</span><br><span class="line">输出：2</span><br><span class="line">解释：下标为 0 ，1 和 2 的乘客年龄分别为 75 ，92 和 40 。所以有 2 人年龄大于 60 岁。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：details = [&quot;1313579440F2036&quot;,&quot;2921522980M5644&quot;]</span><br><span class="line">输出：0</span><br><span class="line">解释：没有乘客的年龄大于 60 岁。</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSeniors</span><span class="params">(vector&lt;string&gt;&amp; details)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;string&gt;::iterator it=details.<span class="built_in">begin</span>();it != details.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">            <span class="type">int</span> age = <span class="built_in">stoi</span>((*it).<span class="built_in">substr</span>(<span class="number">11</span>,<span class="number">2</span>));</span><br><span class="line">            <span class="keyword">if</span>(age&gt;<span class="number">60</span>)  num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>位1的个数</title>
    <url>/2023/10/24/%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F">汉明重量</a>）。</p>
<p><strong>提示：</strong></p>
<ul>
<li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li>
<li>在 Java 中，编译器使用<a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81/5295284">二进制补码</a>记法来表示有符号整数。因此，在 <strong>示例 3</strong> 中，输入表示有符号整数 <code>-3</code>。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 00000000000000000000000010000000</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 11111111111111111111111111111101</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>)  temp++;</span><br><span class="line">        n=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2 的幂</title>
    <url>/2023/10/27/2%20%E7%9A%84%E5%B9%82/</url>
    <content><![CDATA[<p>给你一个整数 <code>n</code>，请你判断该整数是否是 2 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>如果存在一个整数 <code>x</code> 使得 <code>n == 2x</code> ，则认为 <code>n</code> 是 2 的幂次方。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：20 = 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 16</span><br><span class="line">输出：true</span><br><span class="line">解释：24 = 16</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> != <span class="number">0</span> || n &lt; <span class="number">1</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span>(n /= <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>统计能整除数字的位数</title>
    <url>/2023/10/26/%E7%BB%9F%E8%AE%A1%E8%83%BD%E6%95%B4%E9%99%A4%E6%95%B0%E5%AD%97%E7%9A%84%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<p>给你一个整数 <code>num</code> ，返回 <code>num</code> 中能整除 <code>num</code> 的数位的数目。</p>
<p>如果满足 <code>nums % val == 0</code> ，则认为整数 <code>val</code> 可以整除 <code>nums</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = 7</span><br><span class="line">输出：1</span><br><span class="line">解释：7 被自己整除，因此答案是 1 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = 121</span><br><span class="line">输出：2</span><br><span class="line">解释：121 可以被 1 整除，但无法被 2 整除。由于 1 出现两次，所以返回 2 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = 1248</span><br><span class="line">输出：4</span><br><span class="line">解释：1248 可以被它每一位上的数字整除，因此答案是 4 。</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">countDigits</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> num2=num;</span><br><span class="line">    <span class="keyword">while</span>(num2)&#123;</span><br><span class="line">        <span class="type">int</span> val=num2%<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(!(num % val))    count++;</span><br><span class="line">        num2/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>倍数求和</title>
    <url>/2023/10/28/%E5%80%8D%E6%95%B0%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<p>给你一个正整数 <code>n</code> ，请你计算在 <code>[1，n]</code> 范围内能被 <code>3</code>、<code>5</code>、<code>7</code> 整除的所有整数之和。</p>
<p>返回一个整数，用于表示给定范围内所有满足约束条件的数字之和。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 7</span><br><span class="line">输出：21</span><br><span class="line">解释：在 [1, 7] 范围内能被 3、5、7 整除的所有整数分别是 3、5、6、7 。数字之和为 21。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 10</span><br><span class="line">输出：40</span><br><span class="line">解释：在 [1, 10] 范围内能被 3、5、7 整除的所有整数分别是 3、5、6、7、9、10 。数字之和为 40。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 9</span><br><span class="line">输出：30</span><br><span class="line">解释：在 [1, 9] 范围内能被 3、5、7 整除的所有整数分别是 3、5、6、7、9 。数字之和为 30。</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sumOfMultiples</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((i % <span class="number">3</span> == <span class="number">0</span>) || (i % <span class="number">5</span> == <span class="number">0</span>) || (i % <span class="number">7</span> == <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>三个数的最大乘积</title>
    <url>/2023/10/29/%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/</url>
    <content><![CDATA[<p>给你一个整型数组 <code>nums</code> ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,4]</span><br><span class="line">输出：24</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,-2,-3]</span><br><span class="line">输出：-6</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(nums[n<span class="number">-1</span>]*nums[n<span class="number">-2</span>]*nums[n<span class="number">-3</span>], nums[<span class="number">0</span>]*nums[<span class="number">1</span>]*nums[n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>移除元素</title>
    <url>/2023/10/30/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong>。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><br><span class="line">int len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2]</span><br><span class="line">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3]</span><br><span class="line">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=val)    nums[temp++]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣算法题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C2504未定义基类</title>
    <url>/2023/10/31/C2504/</url>
    <content><![CDATA[<h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>这个原因是因为编译基类的h文件中，包含了派生类的h文件，导致派生类在基类之前就已经声明，但是虽然提前声明，可基类依然还是没有声明。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AA.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BB.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BB.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AA.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> :<span class="keyword">public</span> AA</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但在编译AA.h时，其实际文件大概是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BB</span> :<span class="keyword">public</span> AA		<span class="comment">//BB要编译，就需要AA类，但AA类在后面，等同于AA类并没有任何声明，故报错 </span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line">... </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>第一种：可在AA.app中包含BB.h而不是AA.h。像：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AA.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AA.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BB.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二种：先声明类再引用头文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AA.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BB.h&quot;</span></span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>报错问题及解决</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>报错</tag>
      </tags>
  </entry>
</search>
